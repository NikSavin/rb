#Исключения
#raise 'Error'# raise метод для генерации искючений(ошибки) у метода raise есть синоним fail
#fail 'Ошибка'

def say 
  raise 'Error' if rand(2).zero? # Генерация исключительного случая
rescue #Механизм который позволяет выполнять код в исключительном случае
	puts 'Произошла ошибка'
else  #Позволяет выполнять когда ошибка не произошла
	puts 'Ошибка не произошла'
ensure #Механиз который позволяет выполнять код в любом случае
	puts 'Вывод в любом случае'
end 

say

__END__
begin
  raise 'Ошибка' #Генерируем ошибку
rescue #Перехватывает ошибки котоые происходят между begin и rescue
  puts 'Произошла ошибка'
end

begin
  raise 'Ошибка' if rand(2).zero? #rand это метод в руби который генерирует случайные числа.Аргумен (2) означает что берется два числа 0 и 1.Для того что бы получить true или false мы можем сравнить число с 0 (rand == 0). Но лучше использовать метод zero? .
  puts 'Ошибок нет'
rescue
	puts 'Произошла ошибка'
end

#Получение доступа к объекту исключения
begin
  raise 'Ошибка' if rand(2).zero? #rand это метод в руби который генерирует случайные числа.Аргумен (2) означает что берется два числа 0 и 1.Для того что бы получить true или false мы можем сравнить число с 0 (rand == 0). Но лучше использовать метод zero? .
  puts 'Ошибок нет'
rescue => e #Когда срабатывает конструкция raise происходит формирование объекта исключения.Можно получить доступ к этому объекту в блоке rescue с помощью (=> е)
  puts e.message #У объекта исключения e существуют методы например massege или backtrace().
  puts e.backtrace #Получаем цепочку вызовов до места возникновения ошибки.
end

class HelloWorld
  def say
  	raise 'Ошибка' if rand(2).zero?
  	puts 'Ошибки нет'
  end
end

begin
  hello = HelloWorld.new
  hello.say
rescue => e 
  puts e.message
  puts e.backtrace
end


#Так как исключение является объектом у него существует собственный класс.Посмотрим на него в этом примере.
begin
  if rand(2).zero?
    raise RuntimeError, 'Error class RuntimeError' #метод raise может использовать не только строку, но и класс RuntimeError
  else 
  	raise IOError, 'Error class IOError'
  end
rescue RuntimeError => e #Мы можем указать определенный клас исключений который мы перехватываем в блоке rescue в нашем примере перехватываться будут только ошибки RuntimeError.
  puts e.message
  puts e.class #Смотрим класс исключения
end

begin
  if rand(2).zero?
  	raise RuntimeError, 'Error class RuntimeError'
  else 
  	raise IOError, 'Error class IOError'
  end
rescue RuntimeError, IOError => e # Конструкция rescue позволяет создавать несколко блоков, под разные типы ошибок.Несколько блоков используется если содержимое отличается.В нашем случае они полностью одинаковы и поэтому мы записываем их в один блок.
  puts e.message
end


# retry Позволяет несколько раз повторить попытку.В данном примере позволяет 3 раза вывести переменнную tries.
tries = 0
begin
  tries += 1
  puts 'Попытка #{tries}...' #!!!!!!!!!!!!!!!!Почемуто не срабатывает #{tries}!!!!!!!!!!!
  raise 'Error'
rescue
  retry if tries < 3 #Блок между begin и rescue можно попробовать выполнить несколько раз для этого нужно использовать конструкцию retry
  puts 'Попытки закончились' 
end

# Помимо rescue, существуют еще ensure блоки, они выполняются в любом случае не зависимо от того срабатывает исключение или нет.
def say
  #begin Внутри методов можно не использовать слово begin
  	raise 'Error' if rand(2).zero?
  	puts 'No Error'
  ensure  # Не зависимо от того срабатывает исключение или нет все равно срабатывает блок и выводится сообщение "Возвращаемое значение"
  	return 'Возвращаемое значение'
  #end
end

puts say
#
#
#
#
#
#
#
#
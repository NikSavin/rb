arr = %w[red orange black yellow indigo gray violet]

for color in arr
  puts color
end

arr.each do |color| #Если циклы создаются ключевыми словами, то each это метод. 
	#Конструкция do - end это блок.Блоки могут принемать параметры, которые размещаются между вертикальными чертами || в данном случае в блоке размещается параметр color в который передается элемент массива.
	#На каждой итерации в блок передается новый элемент массива.
	#оператор each выполняет блок ровно столько раз сколько элементов находится в коллекции.Если в коллекции находится 5 элементов то он выполнится ровно 5 раз, при этом на каждой итерации в блок будет передаваться ОДИН параметр - значение элемента коллекции.
	#Итератор each не изменяет текущую коллекцию.
	#Если нам надо получить массив с измененной коллекцией нам нужно воспользоваться итератором map.
	puts color
end

#Итераторы более гибкие чем циклы!Например мы можем применить итератор each для обхода hash.

hash = {
  red: 'красный',
  orange: 'оранжевый',
  black: 'черный',
  yellow: 'желтый',
  indigo: 'синий',
  gray: 'серый',
  violet: 'фиолетовый'
}

hash.each do |key, name|#В блок мы передаем два значения,key - соответствующий ключу хеша и name - сответствующий значению.
  puts "#{key} => #{name}"#Каждый из параметров (ключ, значение) мы можем использовать внутри блока. В данном случае мы интерполируем их строку и выводим в методе puts
end

#Блоки имеют две формы.Выше представленна полная форма.Она используется когда блок состоит из нескольких выражений, расположеных на нескольких строках.
#Если выражение одно, ключевые слова do и end можно заменить фигурными скобками {} это будет тоже блок.Смотрим пример ниже.

hash.each { |key, name| puts "#{key} => #{name}" }

# Итераторы не обязательно должны обслуживать коллекции. Например итератор times обслуживает числа и позволяет выполнить цикл указанное количество раз.

#5.times { |i| puts i } #Здесь параметр i будет пробегать значение от 0 до 4.
#Для вещественного числа (5.0) оператор times уже не сработает.Поэтому мы получим ошибку!

#Итераторы это методы!Они могут быть реализованы в классе или нет.Если итератор НЕ РИАЛИЗОВАН мы не сможем им воспользоваться и будем получать ошибку.


#Для итерирования одного числа к другому применяется итератор UPTO.
5.upto(10) { |i| puts i } #Здесь мы пробегаем значение от 5 до 10.Каждая цифра выводится на отдельной строке.

10.downto(5) { |i| puts i }#Метод downto наоборот позволяет пробегать числа с шагом -1.Числа будут выведены в обратном порядке.

ary = [1,2,3,4,5]
p ary
p ary.map { |x| x.even? }#even? возвращает true если элемент коллекции четное число и false если число не четное.

p ary.reject { |x| x.even? }

#Итераторы можно объеденять в цепочки!Например, мы отобрали часть элементов коллекции,далее мы можем преобразовать их при помощи итератора map.
#Создадим коллекцию из нечетных элементов которая возводит их в квадрат:
p ary.reject { |x| x.even?}.map { |x| x * x }

#Блок итератора reduce принемает два параметра! 1 переменую куда накапливаются значения(fact) 2 элементы текущей итерации(x)
p [1,2,3,4,5].reduce(10) { |fact,x| fact * x } #Методу reduce можно присвоить начальное значение в нашем случае это (10)

#Существует 5 итераторов коллекций которые ВАЖНО знать:
#Итератор - Синоним
#each : Оператор each выполняет блок ровно столько раз сколько элементов находится в коллекции.Если в коллекции находится 5 элементов то он выполнится ровно 5 раз, при этом на каждой итерации в блок будет передаваться ОДИН параметр - значение элемента коллекции.
#map - collect : возвращает новую коллекцию, количество элементов в которой совпадает с количеством элементов в исходной колекции.Однако каждый элемент заменен на результат вычисления в блоке.
#select - find_all : Для того чтобы отфильтровать содержимое массива.Блоки select должны возвращать либо true либо false(нужно помнить что nil рассматривается как false, а всё что не является false и nil рассматривается как true).В зависимости от того  возвращает блок true или false элемент коллекции либо попадает в новую либо игнорируется.Т.е. при помощи селектов мы можем фильтровать коллекцию, оставляя только часть элементов.
#reject - delete_if : Полная противоположность итератора select.Он отберает только те элементы для которых блок значения вернул false.
#reduce - inject : Его задача заключается в том чтобы обойти все элементы коллекции и вернуть какое-то одно определенное значение, например сумму элементов коллекции или их произведение и т.д. и т.п.

#Занние всех итераторов помогает нам использовать разные итераторы под разные цели.
origin = []
[1,2,3,4,5].each do |x|
	puts x
	origin << x * x
end
p origin

origin2 = [1,2,3,4,5].tap { |x| puts x }.map { |x| x * x }#Иногда возникает необходимость получить промежуточный результат.Можно было бы вывести эти значения внутри блока как в примере выше(puts x).Итератор tap возвращает исходную колекцию без изменений, и используется только для побочного эффекта.
p origin2

#У итератора tap может быть и другое применение!

=begin
HELP FITHC!!!
class Amy
	def chance_hash(params)
		#params[:page] = 1
		#params
  		params.tap { |x| p[:page] = 1 }
	end
end

amy = Amy.new

puts amy.chance_hash(2)
=end

#Внутри итераторов можно использовать теже управляющие конструкции что и в цикла т.е. break и next.
[*1..10].each do |i| 
	puts i
	next if i > 5
	#break if i > 5
	puts i
end


#итератор loop полная противоположность итератора while.
#loop do 
#	puts 'hello'
#end

#Т.к. итераторы это методы, можно попробовать последовательно разработать свой итератор наподобе loop.
def my_loop
	n = 0
	puts 'Начало метода.'
	yield n += 1
	yield n += 2
	yield n += 3#Что бы метод мог принимать блок мы используем ключивое слово yield.Его задача в том чтобы уступить выполнение задачи внешнему блоку.
	puts 'Завершение метода.'
end

my_loop { |n| puts "Вызов внутри метода. Итерация #{n}" } #Ключивое слово yield запускает выполнение блока.Допустим чтобы вывести фразу "Вызов внутри метода." 3 раза нам нужно напечатать 3 раза ключивое слово yield.


def my_loop_two 
	#if block_given? #block_given? позволяет нам обойти ограничение обязательного блока при использовании метода.Он проверяет передан ли методу блок.Если он передан он возвращает значение true,если он не передан он возвращает false.
		#Таким образом он запускает цикл только в том случае если блок был передан.
	return unless block_given?#в нашем случае можно отрефакторить код и использовать гард выражение, оно позволяет недопустить ошибку если при вызове метода не передан блок. 
	yield while true
	#end
end

my_loop_two#Если не передать в программу блок то будет выводится ошибка.При вызове yield в методе нужно обязательно передать в вызов функции блок.


def my_loop_three(&some)#Блок это специальный параметр метода.Более того мы можем задать его явно.Делается это при помощи символа &(амперсанд) в результате в метод передается объект.
	return unless block_given?
	some.call while true #Для того чтобы уступить вычисление,мы должны вызвать метод call у этого объетка.
end

my_loop_three

#Объект блока(&...) это объект класса Proc.proc объекты часто используются для того чтобы сократить ту или иную конструкцию с участием блока
puts [1,2,3,4,5].select { |x| x.even? }#В данном примере блок отсортировывает только чётные значения
#puts [1,2,3,4,5].select {&:even?} 
# & в данном выражении будет указывать на то что в данном выражении будет применен метод to_proc т.е. данный символ будет привращен в proc объект.
#Такая техника может быть применима к любому другому итератору, например итератору reduce.
puts [1,2,3,4,5].reduce { |fact, x| fact * x}
#puts [1,2,3,4,5].reduce {&:*}
#Обычно proc объеkты не используют для того чтобы передать блок на более глубокий уровень.

require_relative 'proc_test'

p TREE

#TREE.each do |x|
	#case x 
	#when Hash then puts 'dir'
	#when String then puts 'file'
	#end
	#puts 'Dir' if Hash === x #Выводим dir если файл будет Хэш
	#puts 'File' if String === x #Выводим file если файл будет Строка
#end

def walk(arr = [], &block)#proc объект всегда вызываеся в конце параметров, перед ним всегда указывается &.Методу можно передать только один блок и параметр с & присутствует всегда только в одном экземпляре.
	arr.each do |x|
		case x
		when Hash
			x.each { |_dir, file| walk(file, &block) }#рекурсивно вызываем метод walk
		when String then
			block.call x
		end
	end	
end

walk(TREE) { |file| puts file }
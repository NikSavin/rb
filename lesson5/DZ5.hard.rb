#require 'pry'

class Storage
	attr_accessor :stor

	def initialize
	  @stor = {}
	end

	def method_missing(name, *args)
	  method = name.to_s
	  return unless method.end_with?('=')
	  key = method.chomp('=').to_sym
	  @stor[key] = args.first
	end
end

class Setting

	def initialize
	  @obj = Storage.new #Теперь мы можем превратить объект класса obj в объект класса Storage
	  yield @obj
	end

	def method_missing(name) #Вместо того чтобы вызывать методы(send(name)) мы можем непосредственно обратиться к истанс переменной @stor
		#binding.pry
		raise "Неизвестный параметр #{name}" unless @obj.stor.key? name
	  @obj.stor[name] #if @obj.respond_to? name
	end
end

#Запустим программу на выполнение и посмотрим что у нас получилось.
s = Setting.new do |x|
  x.hello = 'world'
  x.page = 1
  x.number = 30
end

puts s.hello
puts s.page
puts s.number

__END__

#Если запустить данную программу она закончиться ошибкой, т.к. инстанс переменная @obj у нас принимает неопределенное значение, а если она принимает неопределенное значение следовательно мы не сможем у нее вызвать никаких сеттеров.
#Как мы сможем обращаться к неопределенному методу например hello(seting.hello)?Как один из вариантов это вызвать метод миссинг, который перехватывает такие обращения и пытается вызвать их у нашего объекта obj

class Setting

	def initialize
		yield @obj#Блок принимает один параметр |s| поэтому мы должны передать yield какой-то объект.Мы пока не знаем что это за объект.
	end

	def method_missing(name)# Если мы получаем вызов неопределеннного метода мы пытаемся адресовать его методу send объекту obj при условии конечно что он отвечает на такие вызовы.
	  @obj.send(name) if @obj.respond_to? name
	  #Очевидно что нам нужно сделать что-то с объектом obj!Он должен быть у нас более умнее чем просто бъект руби!В примере выше разработаем для него класс!
	end
end

setting = Setting.new do |s| #Конструктор объекта принимает блок.
	s.hello = 'world' #Параметр блока
	s.page = 1 #Параметр блока
	s.number = 30 #Параметр блока 
	#Позже мы должны получить возможность обращаться к этим параметрам как к методам объекта.
	#Т.к. конструктор принимает блок вызовем в классе метод initialize который будет принимать метод yield
end

#
puts setting.hello
puts setting.page
puts setting.number


class Storage
	attr_accessor :stor #Здесь мы будем сохранять переданные параметры

	def initialize
	  @stor = {} #По умолчанию объект stor будет пустым hash
	end
end

x = Storage.new
x.hello = 'World'
p x.stor#undefined method `hello=' (NoMethodError)
#если мы запустим программу то увидим что у нас не существет метода hello = .Мы не можем для каждого произвольного параметра свой сеттер, мы просто не знаем какие еще методы прийдут в голову пользователя.
#Например он захочет создать page = 1
x.page = 1
p x.stor #undefined method `page=' (NoMethodError)
#Предугадать какие сеттеры потребуются мы не можем, поэтому мы можем перехватить такие обращения при помощи method_missing.


class Setting
  attr_accessor :stor

  def initialize
    @stor = {}
  end

  def method_missing(name, *args) #Здесь мы будем перехватывать не только значение(name) но и параметры(*args)
  	method = name.to_s #Мы хотим реаировать только на сеттры поэтому если у нас в конце метода нет = мы должны завершить методы.
  	#Поэтому если в конце метода который передается в name у нас нет завершающего = мы должны завершить работу метод_миссинг
  	return unless method.end_with?('=')#проверить наличие равно в конце метода мы можем при помощи специального метода строк end_with? . Покидаем метод (return unless) если нам передан не сеттер.
    #если же нам передан сеттер мы должны сохранить переданное значение в аргументе внутрь инстанс переменной переменной @stor.
    #В качестве ключа хеша мы будем использовать метод который совпадает с иминем параметра например hello= у которого мы отрезаем финальный символ (=) он нам не нужен.
    #Из аргументов(args) мы берем первый метод при помощи метода first
  	@stor[method.chomp('=')] = args.first

#p name# При выводе такой конструкции мы получим:
#:hello= 
#:page=
#{}
# (:,{},=) Символы мы не можем отрезать.Символы не изменяемая величина, поэтому символы мы преобразуем в строки.Вот уже строки мы можем изменять.
  end
end

s = Setting.new
s.hello = 'world'
s.page = 1
p s.stor
#При запуске программы, видим что в инстанс переменной @stor у нас сохранился хеш: {"hello"=>"world", "page"=>1}.В качестве ключа параметров выступает имя параметра(hello, page) в качестве ключа значение которое установил пользователь(world, 1)


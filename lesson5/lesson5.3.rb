#Конструкции можно использовать не только для инициализации объекта но и для различных операций которые могут возникать во время инициализации объекта
#Если у нас стоит клас Ticket и стоит задача подсчета всех выпущеных билетов чтобы не продать большее количество билетов чем у нас есть например в зале, конструктор это идеальное место чтобы осуществить эту операцию.
class Ticket
#Для того чтобы подсчитать количество всех создаваемых объектов, нам потребуется такая переменная которая будет сохранять состояниe для всех элементов класса Ticket.
#Есть всего две переменные которые нам бы сдесь могли пригодиться.Первая это ГЛОБАЛЬНАЯ переменная, но её лучше не использовать.Вторая это переменная КЛАССА (@@)
  @@counter = 0 #Создадим переменную класса и увеличим её значение в конструкторе initialize  
  def initialize
    @@counter += 1#Каждый раз когда будет создаваться объект и вызываться конструктор, а он вызывается всегда ровно один раз.Значение переменной counter будет увеличиваться на 1.
  end

  def counter #Для того чтобы добраться до переменной counter нам прийдется ввести еще один метод, который будет возвращать её значение.
  	@@counter
  end
end
#Теперь можно создать пару объектов и посмотреть как работает наш класс.
ticket1 = Ticket.new
ticket2 = Ticket.new
#Затем выведем значение переменной counter.Посмотрим сколько же у нас создано билетов.
p ticket2.counter

#Блоки могут быть очень полезны при инициализации наших объектов, поэтому они довольно часто используются в конструкторах.
#Ниже разработаем клас который будет использовать блок для инициализации.
class Palitte

  def initialize(colors = [])
  	@colors = colors
  	#Модифицируем класс таким образом что бы конструктор принимал блок.
 	#Мы не должны сломать код в котором конструктор вызывается без блока.Для этого мы используем метод block_given? который проверяет передан ли блок методу.
 	if block_given?
 	  @colors = yield #Мы присваиваем yield который вступает к выполнению внешнего блока инстанс переменной colors.Мы не просто создаем блок,мы берем его результат и ПРИСВАИВАЕМ его инстанс переменной внутри объекта.
    end
  end

  def each
  	@colors.each { |c| yield c }
  end
end
#Минимум готов.Попробуем им воспользоваться.

colors = %w[красный желтый синий зеленый фиолетовый голубой оранжевый]
pal = Palitte.new(colors)
pal.each { |color| puts color }# Воспользуемся вместо метода p итератором each
#p pal #У нас есть объект палитры и в нем инстанс переменная colors, в которую мы передали массив цветов.
puts '#' * 100

#Попробуем создать второй вариант
pal1 = Palitte.new do
	%w[red yellow navy green violet blue orange]
end
pal1.each { |color| puts color }




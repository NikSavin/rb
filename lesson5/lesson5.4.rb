#Логические методы это методы которые заканчиваются на вопросительный знак.Вопросительный знак не изменяет свойств методов, это информационный сигнал о том что метод возвращает либо true либо значение false.Его следует использовать либо в операторах ветвления либо в логических выражениях.
#Давайте рассмотрим класс билета.У него уже есть конструктор который принимает при созании билета цену билета.И есть метод price при обращению к которому мы можем узнать эту цену.Цену мы храним в инстанс переменной(@price) price.
class Ticket
	def initialize(price:, status:)
	  @price = price
	  @status = status
	end

	def price
	  @price
	end

	def status?
	  @status
	end
end

#ticket = Ticket.new(6.5)
#puts format('Цена билета %.2f', ticket.price)
#Допустим нам нужно расширить возможности класса и предоставлять информацию о том куплен билет или ещё нет.
#Давайте введем еще одну инстанс переменную status.
#Теперь нам нужно модифицировать создание билета.
ticket = Ticket.new(price: 6.5, status: true)
puts format("Цена билета %.2f", ticket.price)
#puts ticket.status#У статуса билета может быть только два состояния он либо продан либо нет и логически использовать здесь либо true либо false. 
#В зависимости от состояния которое будет возвращать status выводить ту или иную строку.Т.е. в инстанс переменной @status будем хранить либо true либо false и в зависимости что нам будет возвращать status мы будем возвращать ту или иную строку.
#Мы в инстанс переменной @status будем хранить true либо false и в зависимости что нам будет возвращать метод def status будем выводить ту или иную строку.
#Таким образом класс билета Ticket приобретает большую универсальность так как теперь этот класс можно использовать не только в консоли но и например в веб сервере или например в программе с графической оболочкой.
#Метод status теперь возвращает либо true либо false.Поэтому мы можем добавить сюда знак вопроса(def status?).Он ни к чему не обязывает он лишь информирует пользователя классом что данный метод является логическим.Он ни к чему не обязывает, он лишь информирует что данный метод является логическим.Его уместно использовать в if операторе или в логических выражениях.
#Можно заметить что стандартные методы всегда используют знак вопроса если они возвращают true или false.Хорошим знаком является использование знака вопроса и в меодах своих собственных программ.
if ticket.status?
	puts 'Билет продан.'
else
	puts 'Билет не продан.'
end

#Существуют и другие способы информирования о статусе метода,например восклицательный знак(!).Методы в которых используется ! знак называются бэнк методами.
#Давайте рассмотрим использование бэнк метода на примере.
puts str = 'hello'# создадим строку со значением 'hello'
puts str.upcase #метод upcase возвращает точно такую же строку только с заглавными буквами
puts str #Если мы посмотрим исходную строку то мы можем убедиться что она не изменилась.
puts str.upcase! #Для метода upcase существует альтернативный метод upcase! с восклицательным знаком на конце!Результаты его работы точно такие же однако если мы посмотрим на исходную строку то мы можем заметить что она изменилась.
puts str
#бенк методы часто используются в паре с обычными методами.Обычный метод просто возвращает копию результата не изменяя исходный объект, бэнк метод вносит изменения в объект в отношении которого вызывается метод.
#Рубисты делятся на два лагеря, некоторые считают что бэнк методы следует использовать только тогда когда есть аналогичный метод, безопасный метод который не изменяет оъект.
#Другие считаю что бэнк метод стоит использовать всегда когда у вас метод выполняет опасную,необратимую работу например изменяет состояние базы данных и не имеет значение есть для него безопасный вариант или нет.


#Часто возникают ситуации когда нам нужно сохранить какое-то значение, а потом его извлечь.Методы которые это осуществляют называются сеттерами((set)def set_price) и геттерами((get)def price).Параметры которые нужно присвоить объекту бывает очень много и однотипного кода тоже черезвучайно много.
#Ниже у нас представлен класс билета который принемает дату и цену билета.
class Ticket

#Руби предоставляет специальные методы касса который позволяет сократить объём кода для сеттера и геттера.Речь идет о так называемых аксессорах, методах которые позволяют создать так называемые другие методы.
#Можно избавиться от методов def price и def date если воспользуемся аксессором attr_reader передав ему символы :price, :date.	
#Метод attr_reader создаст за нас метод def price и def date и создаст сколько угодно аналогичных методов если мы передадим их ему через запятую в качестве аргументов.
	#attr_reader :price, :date
#Более того мы можем избавиться и от сеттеров def set_price, def set_date.Воспользуемся другим аксессором attr_writer.
	#attr_writer :price, :date
#У нас до сих пор повтор строк, у нас одинаковые аргументы для attr_reader attr_writer.Мы можем их заменить одним выводом attr_accessor
#attr_accessor создает набор сеттер,геттер для каждого из переданых параметров price и date.
	attr_accessor :price, :date

	def initialize(date:, price: 5.5)
	  @price = price
	  @date = date
	end
#Для сеттеров в руби предназначен специальный синтаксис.Допускается использование создание методов со знаком равенства на конце.
	#Второй вариант #def price=(price)
	#Первый вариант	#def set_price(price)
	  #@price = price
	#end

	#def price
	  #@price
	#end

	##def date=(date)
	#первый вариант	#def set_date(date)
	  #@date = date
	#end
	
	#def date
	#  @date 
	#end
end
#Здесь создается объект билета
ticket = Ticket.new(date: '02.01.2022', price: 6.5)

#Создается небольшой отчет.Цена билета и дата.
puts "Дата мероприятия: #{ticket.date}"
puts "Цена билета: #{ticket.price}"

#Воспользуемся сеттерами класса,т.е. установим им другую дату и другую цену
#ticket.set_price 5.5
#ticket.set_date '22.02.2022'

ticket.price = 4.5
ticket.date = '22.02.2022'

puts "Новая цена билета: #{ticket.price}"
puts "Новая дата мероприятия: #{ticket.date}"
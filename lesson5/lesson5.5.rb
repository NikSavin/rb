#Мы можем открывать не только свои классы но и стандартные класы руби.
#Ниже приведем пример изменения стандартного класса String

puts 'adc'.reverse #reverse изменяет порядок в букв и в консоли выводится cba
#мы можем открыть стандартный класс String и изменить поведение метода reverse.
class String
  def reverse
  	'Изменяем поведение метода.'
  end
  #Мы можем переопределять не только существующие методы но и вводить свои собственные.
  #Мы можем создать метод hello который будет выводить Hello и далее использовать для интерполяции #{self} саму строку.
  def hello
    "Hello, #{self}!"
  end
end

puts 'abc'.reverse #Вместо стандартного метода reverse мы получаем "изменяем поведение метода" мы изменили стандартный метод класса String

puts 'Igor'.hello

#Изменять поведение можно не только для класса String но и для любого другого класса!
#Например мы можем изменить поведение класса Integer который отвечает за целые числа.
puts "Цена билета #{500} рублей."
#Если разблокировать то ниже сломается пример с константой Х и модулями!
#class Integer
#  def to_s
# 	"Мы всё сломали!"
#  end
#end

puts "Цена билета #{500} рублей."

#Техника изменения класса опасна.Опасна она не только тем что мы можем влиять на работу своей программы но и на работу других библиотек которые мы подключаем.Как правило к этой технике пребигают когда нужно модефицировать язык, например фреймворк Ruby on Rails открывает практически все классы Ruby и вносит туда свои методы, исправляет существующие.Поэтому о RoR часто говорят как о другом языке программирования.Это не корректно, это тот же язык программирования Ruby, но тем не мение правила,поведение и соглашения настолько отличаются от оригинального языка Ruby что на практике приходится изучать RoR довольно внимательно и он довольно сильно отличается от оригинального языка.
#Идея построения фактически нового языка заложена в Ruby изначально.
#Техника открытия класса давольно спорная!К ней стоит прибегать только если мы уверенны в своих действиях!Это скорее инструмент разработки библиотек, разработки новых систем, не инструмен построения конечных приложений.
#Как видно мы можем с легкостью открыть класс, поправить его или просто сломать.Поэтому довольно большое значение в Ruby приобретает пространство имен.
#Пространство имен создаются при помощи модулей(module),мы можем поместить наши классы в модули и они будут изолированны от других классов находящихся либо в глобальной области либо в другом пространстве имен.
#Пространство иьён отделяется от других классов двоеточием(::)
module Hello
	class World
	  def say
	  	puts 'Определяем метод 1.'
	  end
	end

	class World
	  def say
	  	puts 'Определяем метод 2.'
	  end
	end
end
#Для того чтобы воспользоваться классом World который определен модулем Hello нам нужно написать ИМЯ МОДУЛЯ Hello УКАЗАТЬ :: и лишь потом имя класса World
hello = Hello::World.new
hello.say
#При работе с модулями мы обращаемся к константам.
#Модули это такие же классы.Единственное отличие в том что при помощи class мы можем создавать объект, у module не может быть объекта.Назначение модуля это хранить другие классы модули и методы.Т.е. фактически модуль управляет доступом к константам.
#Ниже представленна сложная структура которая содержит разные константы Х 

Z = 6
X = 3 #Перед нами сложная структура которая содержит разные константы X
module M #У нас есть модуль М
  	class C #В него вкладывается класс С
  	  X = 2
  	  Z = 4
  	   class D #В класс С вкладывается класс D
  	  	 module M #Внутри мы можем так же использовать модуль, например М
  	  	  X = 1
  	  	  #Когда мы находимся на уровне модуля М мы можем указать Z без указания пространства имен.
  	  	  Z = 2 
  	  	  puts "Z = #{Z} на уровне модуля М."
  	  	  puts "Z = #{::Z} Обращение на уровне глобальной константы в модуле М."
  	  	  end
  	   end
    end
end

puts X #Если мы сейчас обратимся к константе Х мы обратимся к глобальной константе Х = 3
puts M::C::X #Для того чтобы обратится к константе Х на уровне класса С мы должны указать пространство имен.
puts M::C::D::M::X #Для того чтобы нам обратится к константе Х в модуле М нам нужно указать весь путь!

#Очень часто константа выделяется в отдельные модули которые мы используем с использованием пространства имен.Таким образом пространство имен преобретает еще и информационные функци делая программу более читабельной.
class Worker
	#module Error#Модуль Error в данном примере мы можем вынести за приделы класса
	  #SALARY = 'Зароботная плата должна быть больше нуля.'
	  #NAME = 'Введите корректное имя'
	#end

  def hello
    puts Error::SALARY
  end
end

class Worker::Error#Ели в определении класса видно :: нужо знать что речь идет либо о классе либо о модуле в который вложен данный класс или модуль.
#Так программа будет короче и более читайма.
  #module Error#Мы можем сократить эту строчку с помощью :: и передать ее в class Worker::Error
  	SALARY = 'Зароботная плата должна быть больше нуля.'
	NAME = 'Введите корректное имя'
  #end
end

puts Worker::Error::SALARY

#Использую влияние пространства имен мы можем изолировать технику открытия классов на всю систему.
#Ниже мы открываем класс Array внутри модуля MyNamespace, таким образом мы НЕ ПОВРЕЖДАЕМ ГЛОБАЛЬНЫЙ КЛАСС Array и его поведение остается оригинальным.
module MyNamespace
  class Array
  	def to_s
  	  "Мы всё сломали Карл"
  	end
  end
end

p Array.new #Остается оригинальное поведение, создается пустой массив []
p MyNamespace::Array.new #Создается новый объект в памяти хеш #<MyNamespace::Array:0x00...
#Таким образом изолируя классы, мы ограждаем другие классы от повреждений

#Открывать можно не только классы но и модули.Например все стандартные методы которые используются в глобальной области помещаются в модуле Kernel.
#Мы помним что у каждого метода должен быть получатель.Метод не может вызываться без объекта.
Kernel.puts 'Kernel module original.'

module Kernel
  def say
  	puts 'Записали в Kernel свой метод say.'# Когда мы записываем puts в метод say мы можем уже не использовать его для вызова метода.
  	#'Записали в Kernel свой метод say.'
  end
end

say
#puts say





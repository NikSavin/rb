#До текущего момента мы использовали модули чтобы изолировать используемые нами классы чтобы они не открывали и не вносили изменения в уже существующие либо в глобальной области видимости либо в какой нибудь сторонней библиотеки.
#Ниже представленная область видимости MyNameSpace которая организуется с помощью модуля.В неё помещён класс Array. Таким образом у нас есть собственный класс Array и мы никак не затрагиваем стандартный класс Array который предназначен для обслуживания массива.

module MyNameSpace
  class Array
  	def to_s
  	  'My class'
  	end
  end
end

p Array.new#В глобальной области возвращается массив.
p MyNameSpace::Array.new#Ведет себя как обычный объект.

puts '#' * 25

puts Array.new
puts MyNameSpace::Array.new

#Модули создаются при помощи ключевого слова module, далее следует название модуля обязательно в кэмел кейс режиме и закрытие с помощью end. Модуль это тоже объект как и  практически все в руби.
module Hello
end
#Посмотрим к какому классу относится наш модуль:
puts Hello.class
#Видим что наш модуль относится к классу Modul
#Как связаны модули с остальными классами языка руби?
#Давайте посмотрим на это при помощи консоли и irb
#Любой class языка руби является объектом класса Class
#2.4.2 :001 > Object.class
# => Class
#При этом class Class наследуется от class Module
#2.4.2 :002 > Class.superclass
# => Module 
#Module же в свою очередь наследуется от class Object
#2.4.2 :003 > Module.superclass
# => Object
#Для того чтобы все это уложить в голове можно посмотреть на схему наследования языка Ruby.
#BasicObject
#    |
#  Object--------->Module
#    |                |
#  Greet---объект---Class
#В вершине иерархии находится класс BasicObject от него наследуется класс Object
#Когда мы создаем любой базовый класс руби он автоматически не явно наследуется от Object. Например Greet это наш пользовательский класс который мы создаем при помощи ключевого слова class.
#класс Module так же наследуется от класса Object, при этом класс Class наследуется от Module.
#На самом деле классы и модули это близкие родственники.класс Module является базовым для класса Class.
#Фактически Class это тот же Module, только снабженный дополнительными модулями для создания объекта.
#Самое удивительное что все 5 классов представленых на схеме являются объектами класса Class.
#Тоесть руби представляет собой змею пожирающую собственный хвост.Разумеется это противоречие разешено на уровне интерпритатора при помощи кода на С.
#Итак Module в отличии от Class это просто контейнер для констант и методов.



#В Ruby у каждого класса может быть лишь один базовый класс.Т.е. в Ruby используется одиночное наследование, НЕ ПОДЕРЖИВАЕТСЯ МНОЖЕСТВЕННОЕ НАСЛЕДОВАНИЕ как в других языках например С++ или Python.
#такая схема не позволяет естроить разветвленные графы, а позволяет строить только иерархические структуры(иерархические деревья).Тем не менее в мире не все структуры описываются при помощи иерархии.
#Вернемся к нашему примеру который связан с сайтами.
#Например у нас есть 3 страницы: News,About,PhotoCatalog
#Допустим мы принимаем решение что нам нужно снабдить часть наших страниц CEO информацией, это ключевые слова, описание страницы и тайтл заголовок.
#СЕО информация видна только поисковым роботам, она не видна пользователям и находится в специальных html тегах откуда роботы ее могут извлечь.
#Так так в PhotoCatalog у нас практически нет текстовой информации, мы не хотим туда добавлять никакой СЕО информации.Снабдим СЕО информацией только News и About.
#Если мы разместим эту информацию в Page то она будет отображаться и в PhotoCatalog.
#Мы могли бы разместить информацию непосредственно в классе News About, но тогда мы будем нарушать принцип DRY(Don’t Repeat Yourself - не повторяйтесь!)
# Мы будем повторять код один в один и если нам прийдеться его исправить нам прийдеться делать это в нескольких местах!Рано или поздно мы забудем где нибудь поправить код и это приведет к ошибке!Важно чтобы код НЕ ПОВТОРЯЛСЯ, чтобы его можно было править только в одном месте.
#здесь бы нам и пригодилось множественное наследование, когда мы могли бы унаследовать для класса News и About ещё один класс.Руби это не поддерживает но он предоставляет другой механизм.Он позволяет создать МОДУЛЬ и подмешать его в класс!
#Создадим модуль СЕО и продемонстрируем на практике как это работает.
module Seo #Создаем модуль Сео
  attr_accessor :keywords, :seo_title, :description #Геттеры и сеттеры для keywords,seo_title,description.
end
#Теперь мы можем подмешать этот модуль для News и About.Для этого используется ключевое слово include
class Page
  attr_accessor :title, :body, :headers
end

class News < Page
  include Seo
  attr_accessor :date
end

class About < Page
  include Seo
  attr_accessor :phones, :adress
end

class PhotoCatalog < Page
  attr_accessor :photos
end

# Создадим страницу About и попробуем воспользоваться новыми сеттерами!

about = About.new

about.title = 'О нас'
about.body = 'Lorum '
about.phones = ['+7 952 *** ****','+7 921 *** ****']
about.keywords = 'Ruby, module, подмешивание.'#Подмешаный объект модуля Сео

#Выводим дамп объекта about и посмотрим в консоли на результат работы.В консоли увидим что дамп объекта about содержит инстанс переменную keywords.Эта инстанс переменная появится только в объектах класса News и About, куда мы подмешали module Seo.
p about

#Модуль можно подмешивать не только в класс но и на уровень объекта!
#Таким образом при помощи модуля мы можем создавать не только инстанс переменные которые доступны на уровне объекта но и классовые переменные которые будут доступны на уровне класса.Только в этом случае вместо метода include нам потребуется воспользоваться методом extend.

#У нас есть модуль Hello с методом some.Подмещаем его на уровень класса.
module Hello
	def some(name)
	  "Hello, #{name}!"
	end
end
#Создаем класс Greet(приветствие)
class Greet
#Подмешиваем модуль с помощью метода extend
  extend Hello
end
#Воспользуемся классом и посмотрим на результаты программы.
puts Greet.some('word')
#Мы не создавали объектов класса Greet мы сразу воспользовались методом say.Таким образом мы создали классовый метод.



#Все стандартные методы руби которые размещены в глобальной области видимости сосредоточены в стандартном модуле Kernel.
puts 'Hello'
Kernel.puts 'Hello!'
#Строки сверху полностью эквивалентны.
#Модули можно открывать точно так же как классы.Мы можем открыть системный модуль Kernel и дописать туда свой собственный метод.
#Это приводит к тому что у нас в глобальной области видимости появляется метод say.
# module Kernel #Разумеется нет надобности чтобы открывать модуль Kernel и писать в него методы
 #Более правильно просто создать метод в глобальной области.
 #Тем не менее о модулe Kernel нужно знать так как он встраивается в цепочку наследования классов, следовательно будет влиять на то как будет осуществляться поиск метода.
  def say
  	'hello'
  end
#end

puts say

#class BasicObject------------------->
#       |                             |
#class Object <-----------------module Kernel
#include Kernel
#       |
#class Greet

#Модуль Kernel подмешивается на уровень класса Object это означает что для объекта класса Greet поиск методов будет осуществляться следующим образом:
#Сначала метод будет искаться в Greet
#Если метода нет в классе Greet поиск поднимается на уровень выше и ищет метод в классе Object
#Если и там не будет обнаружен метод руби будет искать метод в модуле Kernel
#Если и там метод не обнаружен он поднимается еще на уровень выше и ищет его в классе BasicObject
#Так как у базового класса BasicObject нет базовых классов то искать дальше НЕГДЕ.
#Не обнаружив метод в BasicObject руби гинерирует сообщение об ошибке.
#Если на разных уровнях реализовано несколько одноименных методов будет реализован первый найденый именно по этому важно знать и понимать как классы и модули взаимодействуют друг с другом.

#Схема которую мы рассмотрели с помощью Kernel действует точно так же и в отнашении наших собственных модулей
#class Object--------------------->
#      |                           |
#class Greet                       |
#include Hello<-------------module Hello
#      |
#class H<Greet
#
#Если мы пдмешиваем модуль на уровень класса Greet то поиск осуществляется в этом классе и лишь потом в модуле Hello
#После того как поиск не удался в модуле Hello руби поднимается выше к базовому классу в даном случае к классу Object
module Some
  def cat(name)
  	"Name cat #{name}"
  end
end

class CatName
  include Some
end

names = CatName.new

puts names.cat('Barsic')

#Всегда можно проверить цепочку наследования с помощью метода ancestors
#Воспользуемся ancestors для того чтобы отследить цепочку для класса Greet и базового класса Object.
p Object.ancestors #[Object, Kernel, BasicObject]
p Greet.ancestors #[Greet, Object, Kernel, BasicObject]
p CatName.ancestors#[CatName, Some, Object, Kernel, BasicObject]
#Видим что выводится полная цепочка наследования
#Если возникают сомнения как будет выводится цепочка всегда можно обратиться к методу ancestors который подскажет правельный порядок поиска метода.
#
module GoodDay
  def good(date)
    "Хороший день #{date}"
  end
end

class Good
#Порядок в котором ищутся методы можно изменить.
#Если мы заменим метод include на prepend то сначала будет осушествляться поиск в модуле GoodDay, а уж потом в классе Good.

  prepend GoodDay
  #include GoodDay

  def good(date)
    "Good day #{date}"
  end	
end

gd = Good.new
p gd.good(Time.now)
p Good.ancestors 
#Цепочка при вызове с методом include: [Good, GoodDay, Object, Kernel, BasicObject]
#метод выводится из класса Good

#Цепочка при методе prepend: [GoodDay, Good, Object, Kernel, BasicObject]
#метод выводится из модуля GoodDay
#ТАким образом используя метод include либо prepend мы можем поставить поиск модуля в цепочке метода либо перед классом либо после класса.
#
#                    class C <===========
#                    end                |
#                                       |
#                                       |
#                 class D<C             |
#    ========== > prepend M          module N
#    |            include N =======> end
#    |                   
#    |                   
#  module M          object = D.new
#  end	    <======= object.x
#На схеме сверху ищется метод .х объекта object
#При его поиске сначала будет опрошен module M который подключается при помощи prependr
#  Потом class D
#    потом module N
#      и лишь затем базовый class C
#        если и в нём не будет обнаружен метод .х поиск будет продолжаться дальше
#          class Object
#            module Kernel
#              class BasicObject











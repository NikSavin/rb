#Расссмотрим простейший класс Base который содержит инстанс метод say.
#Если мы создадим объект данного класса мы можем вызвать метод say и в качестве результата получим 'hello'
class Base
  def say
    'hello'
  end
end

class Base
  def say
    'hello world'
  end
end 
object = Base.new
p object.say

#Мы можем повторно открыть класс и перезаписат метод say например чтобы он возвращал строку hello world

puts object.say
#методы можно перезаписывать не только в существующем классе но и в цепочке наследования
#Ниже представленна программа у которой метод D наследуется от базового класса Base.Мы перезаписываем в новом классе D метод say.

class D < Base
  def say
    'Hello World!'
  end
end 
#В результате при вызове метода, будет срабатывать метод класс D, а не Base
object = D.new
puts object.say

#Операторы в руби это тоже методы!Даже когда мы вызываем оператор + (5+2) мы вызываем метод плюс у объекта 5, передавая ему объект 2.
#Это касается всех остальных операторов например оператор ===, мы используем его чтобы узнать пренадлежит текущий объект к данному классу или нет?Это тоже явлеется методом.  String === 'Hello' => true.


#Разь операторы являются методами, мы можем их перегружать в наших классах.Зачем это может потребоваться?
#Например у нас есть класс билета у которого есть два свойства: цена(price) и дата мероприятия(date).
class Ticket
	#Подключаем стандартный модуль Comparable для метода НЛО (<=>)
    include Comparable
	attr_accessor :date, :price

	def initialize(date:, price:) 
#Сохраняем свойства в двух инстанс переменных которые инициализируем с помощью метода initialize
	  @date = date 
	  @price = price
	end
#Реализуем метод плюс +. Обращаем внимание что метод + возвращает тот же самый объект. Мы хотим в 61 строчке сложить объект с числом и получить объект ticket с увеличеной ценой.Поэтому в качестве результата метод + должен вернуть ссылку на объект ticket.Проще всего это сделать воспользовавшись ключевым словом self, которое ссылается на текущий объект.
	def +(number)
	  @price += number
	  self
	end

	def <=>(ticket)
	  @price <=> ticket.price
	end
#Добавляем оператор меньше(<) для реализации сравнивания билетов ticket1 и ticket2.
	#def <(ticket)
	  #@price < ticket.price
	#end
end
#Создаем объект с ценой и датой.
ticket = Ticket.new(date: '22.02.2022', price: 500)

#Допустим мы хотим увеличить цену билета и хотим для этого воспользоваться оператором + .
#если мы сейчас запустим программу мы потерпим неудачу т.к. оператор + не реалезован на уровне класса Ticket, мы не можем им воспользоваться.Давайте его реализуем в классе Ticket.
ticket += 300#Теперь когда у нас в классе есть метод + наша программа работает без ошибки!

#Выводим небольшой отчет
puts format('Цена билета %.2f', ticket.price)
puts "Дата мероприятия: #{ticket.date}"

#Что если мы захотим использовать другой оператор? Например оператор сравнения?Допустим мы хотим сравнить по цене два билета.

#создаем 2 одинаковых билета
ticket1 = Ticket.new(date: '30.02.2022', price: 500)
ticket2 = Ticket.new(date: '30.02.2022', price: 500)
ticket3 = Ticket.new(date: '30.02.2022', price: 800)
#увеличиваем цену билета 2 на 300
ticket2 += 300

#Сравниваем стоимость билетов 1 и 2 и получаем ошибку т.к. метода < у нас нет!Это означает что мы не можем сравнивать два билета по стоимости.
#Ruby ничего знает о том как устроена наша программа, хотим мы сравнивать наши билеты по стоимости или по дате или мы выбирем какой-то другой критерий?Это мы должны запрограммировать самостоятельно!
#В классе Ticket мы должны реализовать оператор <(меньше)
if ticket1 < ticket2
	puts 'Билет 2 стоит дороже билета 1.'
else
	puts 'Билет 1 стоит дороже билета 2.'
end

#Теперь у нас в операторе if три состояния: 1) Билет3 больше билета2. 2)Билет2 больше билета3. 3)Билеты равны по стоимости.
#Если мы посмотрим результат в консоли мы увидим что теперь у нас не хватает оператора больше(>).
#Мы могли бы реализовать все логические операторы(<, >, >=, =<, ==, ===, <=>, !=, =~ ) но это не совсем конструктивно.
#Если заводить все логические операторы в класс Ticket их будет много и логика их повторяется,мы не будем придерживаться принципа DRY!
#Мы можем воспользоваться оператором НЛО(<=>).
#НЛО сравнивает значения друг с другом и возвращает 3 состояния:
# 1) 1 <=> 0 ---- 1 Если одно состояние больше другого возвращает 1
# 2) 0 <=> 1 ---- -1 Если меньше возвращает -1
# 3) 1 <=> 1 ---- 0 Если значения равны возвращает 0
# Оператора НЛО достаточно чтобы построить все остальные операторы сравнения.
# Поэтому если мы реализуем этот оператор и подключим стандартный модуль comparable мы автоматически реализуем все операторы сравнения.
if ticket2 < ticket3
	puts 'Билет 3 больше билета 2.'
elsif ticket3 > ticket2
	puts 'Билет 2 больше билета 3.'
else
	puts 'Билеты стоят одинаково.'
end

#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#Пусть у нас есть стандартный класс Ticket который позволяет сохранять цену билета в инстанс переменной прайс(@price) и дату(@date).
#Билет мы инициализируем при помощи метода initialize
class Ticket
  attr_accessor :date, :price

  def initialize(date:, price:)
    @date = date
    @price = price
  end
# Для того чтобы вывод был более информативным переопределим метод to_s
# Метод to_s будет возвращать небольшой отчет, дату(date) и цену(price)
  def to_s
    "дата - #{date}, цена - #{price}"
  end

  #def to_str
    #{}"цена-#{price} ,дата-#{date}" 
  #end
#Сейчас у нас содержимое метода to_s и to_str повторяются. Избавимся от повтора с помощью ключевого слова alias.
  alias to_str to_s
#Таким образом мы научили класс Ticket вести себя как строка.Мы можем складывать объект или можем его интерполировать.
end

#Создаем объект билета(ticket)
ticket = Ticket.new(date: '20.25.2022', price: 1000)

#Вывидем информацию о билете.
puts "Билет: #{ticket}" #БЕЗ МЕТОДА to_s !!!! Видим что выводится дамп билета, название класса (Ticket:) и адрес в оперативной памяти который ссылается на участок где расположен объект(например: 0x00007feae50af1e0).
                        #С МЕТОДОМ to_s!!!! При интерполяции объекта в строку метод to_s вызывается автоматически.Мы могли бы написать его явно(#{ticket.to_s}), но в этом нет необхоимости!

#Однако если мы сейчас захотим воспользоваться оператором + и сложить строку "Билет: " с объектом (ticket) у нас ничего не получится, программа сломается т.к. класс Ticket не перегружает метод + .
# puts "Билет: " + ticket #in `+': no implicit conversion of Ticket into String (TypeError from lesson6.4.rb:in `<main>'
#Как одним из решения данной проблемы мы могли бы воспользоваться методом to_s
puts "Билет: " + ticket.to_s
#Однако есть способ не использовать метод to_s явно!Для этого мы должны реализовать в классе метод to_str.Если в классе реализован метод to_str он рассматривается как строка, это автоматически позволяет складывать даный объект со строкой.
puts "Ваш билет: " + ticket


#Мы можем научить наши классы вести себя не только как строка, но и как массив.
#В классе User мы можем сохранить фамилию(family), имя(name) и отчество(patronymic).Для этого используются соответствующие инстанс переменые.Научим объекты данного класс вести себя как массив.
class User
  attr_accessor :name, :family, :patronymic

  def initialize(name:, family:, patronymic:)
  	@name = name
  	@family = family
  	@patronymic = patronymic
  end
#По аналогии с метод to_s мы можем реализовать метод to_a.
#Данный метод(to_a) используется для реализования объекта к масиву.
  def to_a
  	[@family, @name, @patronymic]
  end
#Так мы создаем синоним to_ary для метода to_a.Это поможет нам складывать массивы друг с другом.
  alias to_ary to_a
end
#
user = User.new(family: 'Савин', name: 'Николай', patronymic: 'Владимирович')

p user.to_a #Данный метод работает.
#Если мы сейчас попытаемся сложить один массив с другим, мы потерпим неудачу!
p ['программист', 'ruby'] + user #БЕЗ МЕТОДА to_ary!!! no implicit conversion of User into Array (TypeError)
								 #С КОНСТРУКЦИЕЙ alias to_ary to_a!!! ["программист", "ruby", "Савин", "Николай", "Владимирович"]


#В Ruby не имеет смысла говорить о типах.Формально у нас есть числа,строки,массивы.Однако мы можем научить любой объект вести себя как число,строка или массив.
#В языках программирования в которых объекты ведут сбя подобным образом говорят о DuckType-типизации:
#Если объект плавает как утка,крякает как утка - это и есть утка.Т.е. если объект отзывается на метод to_s,to_str - это и есть строка, НЕ СМОТРЯ НА ТО ЧТО ЕГО КЛАСС НЕ ЯВЛЯЕТСЯ КЛАССОМ STRING!!!
#Именно по этому ореинтироваться в ruby на имена классов КРАЙНЕ ОПАСНО!Мы можем открыть любой класс и расширить его возможность, можно создать объект данного класса и изменить его при помощи синглитон метода.
#КОГДА МЫ ИСПОЛЬЗУЕМ ОБЪЕКТ МЫ ДОЛЖНЫ СПРАШИВАТЬ ОТВЕЧАЕТ ОН НА ТОТ ИЛИ ИНОЙ МЕТОД.Т.е. крякает он как утка и крякает ли он как утка.Если ответ положительный это и есть искомый нами объект.

#Создадим два класса Duck и PseudoDuck
module Duckable
  def quack
    'Кряк'
  end

  def swim
    'Плавает как утка'
  end
end

class Duck
  include Duckable
  #def quack
    #'Кряк'
  #end

  #def swim
   # 'Плавает как утка'
  #end
end

class PseudoDuck
  include Duckable
  #def quack
  	#'Кряк'
  #end

  #def swim
  	#'Плавает как утка'
  #end
end
#Создаем два объекта данного класса
duck = Duck.new
object = PseudoDuck.new
#Видим дамп объектов
puts duck#<Duck:0x00007fdc160face0>
puts object#<PseudoDuck:0x00007fdc160facb8>

#Чтобы нам проверить что два объекта утки нам нужно проверить как метод quack так и метод swim.
#Делаем мы это при помощи метода respond_to?
#respond_to? - проверяет отзывается объект на тот или иной метод.
if duck.respond_to?(:quack) && duck.respond_to?(:swim)
	puts 'duck - это утка'
end

if object.respond_to?(:quack) && object.respond_to?(:swim)
	puts 'object - это утка'
end

#При желании мы можем научить вести себя как утка любой объект!Давайте создадим объект cat и снабдим его двумя синглитон методами quack, swim.

cat = Object.new

def cat.quack
  'Кряк.'
end

def cat.swim
  'Плавает как утка.'
end
#Добавляем проверку respond_to?
if cat.respond_to?(:quack) && cat.respond_to?(:swim)
  puts 'cat - это утка'
end
#Запускаем консоль и видим что все три объекта являются утками.
#Таким образом если мы хотим выяснить природу объекта ПРОВЕРЯЙТЕ ЕГО МЕТОДЫ,НЕ ПРОВЕРЯЙТЕ НАЗВАНИЕ ЕГО КЛАССА!
# Обратим внимание что класс Duck и класс PseudoDuck идентичны!Здесь лучше создать модуль и подключить его в классе.
# Таким образом самым простым способом обучить класс вести себя как утка это включить в него модуль Duckable.


#Существует встроеные модули которые ведут себя схожим образом.С одним из них мы познакомились на прошлом уроке(Comparable)
#Comparable - позволяет обучить объект сравнивать друг с другом по заданым правилам.
#Существует еще один модуль Enumerable
#Enumerable - позволяет научить класс вести себя как коллекция, например как массив.Достаточно внести модуль Enumerable в класс и включить метод each.
#Остальные итераторы map,reject,inject будут реализованы с использованием единственного метода each.
#Попробуем разработать класс радуги(Rainbow), который будет возвращать колекцию цветов радуги.
class Rainbow
  include Enumerable
#Мы реализовываем метод each с помощью метода yield.7 раз уступим выполнение метода each блоку, каждый раз передавая очередной цвет радуги.
  def each
  	yield 'красный'
  	yield 'оранжевый'
  	yield 'желтый'
  	yield 'зеленый'
  	yield 'голубой'
  	yield 'синий'
  	yield 'фиолетовый'
  end
end
#Создадим объект данного класса
r = Rainbow.new
#Попробуем воспользоватся объектом r. Для начала просто вывидем цвета с помощью метода each который мы разработали.
r.each { |c| puts c }
#Теперь мы можем воспользоваться каким небудь методом модуля Enumerable.Например методом find которыйпозволяет найти цвет по определенному правилу, мы будем искать цвета которые начинаются на букву "ф".
puts r.find { |c| c.start_with? 'ф'} #Видим что у нас выводиться фиолетовый цвет.
# методов который предоставляет нам Enumerable огромное количество.
#Например известный уже нам итератор map который позволяет нам получить новый массив.
# Давайте получим список цветов заглавными буквами.
puts r.map { |c| c.upcase }
#Мы можем воспользоваться proc объектом.Так гораздо короче.
puts r.map(&:downcase)



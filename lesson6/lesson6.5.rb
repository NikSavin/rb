#self это ссылка на текущий объект, в подавляющем большенстве случаев self используется не явно.Важно понимать на что он ссылается в определенный момент времени.
#В качестве демонстрации воспользуемся использованием сеттеров в блоке initialize

class Ticket #В классе у нас есть два свойства, цена(price) и дата(date)
	attr_accessor :date, :price #при помощи attr_accessor мы создаем две пары методов геттер и сеттер для наших свойств.Им соответствуют инстанс переменные @date, @price

	def initialize(date:, price:)
		date = date # Руби не определяет date = , price =  как методы, он рассматривает эти выражения как присваивание значений локальным переменным = date, = price.
		price = price # Для того чтобы руби расматривал их как сеттеры, нам необходимо явно указать получателя. В качестве получателя как раз и выступает ссылка на текущий объект - ключивое слово self!
		
		self.date = date # В подавляющем большенстве случаев мы не указываем self явно.Если рубисты могут чтото опустить они обязательно это опускают=)Но как видно иногда приходится использовать self.Всегда надо понимать на что в даный момент ссылается self, к какому объекту неявно будет адрессован вызов метода.
		self.price = price
		#@date = date
		#@price = price
	end
end
#Создадим объект и посмотрим на его дамп

ticket = Ticket.new(date: '12.12.2022', price: 10.5)

p ticket ##<Ticket:0x00007fa7f78673f0 @date="12.12.2022", @price=10.5>
#Как видим у нас есть инстанс переменная @date и @price.Давайте остановимся подробнее на attr_accessor который создает 4 метода: 2 сеттера и 2 геттера.
#Для этого воспользуемся instance_methods для нашего класса Ticket.Данный метод очень похож на метод methods, только в отличии от него он возвращает инстанс методы.Т.е. методы которые будут доступны в объекте данного класса.
p Ticket.instance_methods(false) # Чтобы исключить методы из цепочки наследования например методы которые добавляет Object и BasicObject необходимо добавить параметр (false).В этом случа будут определены только те методы которые определены непосредственно в классе Ticket.
#Видим что в консоли второй строкой выводиться список из 4 элементов: [:date, :date=, :price, :price=].Это методы которые были добавлены attr_accessor. 2 getter :date,:price и 2 setter :date=,price=.
#Это означает что в методе initialize мы могли бы воспользоваться только сеттерами price = price, date = date.Однако если запустить программу ничего не получиться!Мы получим пустой объект!Объект ticket у нас не содержит ни одной инстанс переменной #<Ticket:0x00007fc473856f80>

#Self в каждой точке программы ссылается на разные объекты всего различают несколько областей видимости в которой ключивое слово self ссылается на разные объекты: 1) Глобальная область, 2)Инстанс-методы, 3)Уровень класса или модуля, 4)Синглтон-метод.
#Переход границы областей видимости приводит к тому что ключивое слово self начинает ссылаться на другой объект.Крайне важно понимать на что в данный момент ссылается self.
#Ниже мы пройдемся по всем областям видимости и выясним на что ссылается ключивое слово self.

#1) Глобальная область видимости 
puts self #Видим что ключивое слово self ссылается на глобальный объект!Вместо дампа он возвращает main.Это связано с тем что у него перегружен метод to_s(self.to_s).
#Посмотрим на класс данного объекта:
p self.class #Видим что объект глобальной области видимости, это объект класса Object.

#2) Уровень классов и модулей:
class Some
	puts 'Класс Some'
	puts self # Some
module Sum
	puts 'модуль Sum'
	puts self # Some::Sum
end
	puts 'Возвращаемся в класс Some'
	puts self # Some
end
#Внутри класса ключивое слово self ссылается на объект класса Some, а внутри модуля на объект модуля Some::Sum.
#Запомним эти результаты так как они очень важны!Мы можем ссылаться не только на текущий объект но и заменять константу Some, а так же Some::Sum на self.
#При программировании на руби будет интенсивно использоваться данный приём.

#3) Уровень Уровень инстанс метода - метод который будет доступен объекту класса Cat
class Cat
  def name
  	puts self
  end
end
#Чтобы воспользоваться методом, нам нужно создать объект класса Cat
cat = Cat.new #Создаем объект
cat.name # Вызываем инстанс метод name, который сообщит нам на что ссылается self внутри инстанс метода.
p cat #Выводим дамп объекта cat
#Видим что ключивое слово self ссылается на текущий объект.Мы получили две обсалютно одинаковые строки.Внутри инстанс метода мы ссылаемся на будующий объект, т.е. объект который будет создан при помощи метода new.

# Уровень синглитон-методов.
ticket1 = Object.new #Создаем объект ticket1 класса Object

def ticket1.price #Объявляем синглитон метод на этом объекте 
  self #В качестве результата данный метод возвращает self.
end 
# Выведем дамп объекта и сравним результаты.
puts ticket1.price # Ссылка на self
p ticket1 # Дамп объекта
#После вывода в консоли мы можем убедиться что ключивое слово self ссылается на сам объект для которого объявлен данный синглитон метод.


#Из поведения self имеется несколько следствий:
#Мы можем использовать self при определении методов класса, которые являются синглитон методами объектов класса.
#Определим классовый метод и посмотрим как его можно использовать.
#Пусть у нас есть синглон-метод, который мы определяем на объекте класса Dog
class Dog
#Синглтон-метод мы можем разместить между ключевым словом class и end.В руби внутри класса мы можем размещать любой руби код.
#Мы знаем что ключивое слово self ссылается на объект класса,а это означает что мы можем заменить получатель у метода gav на self.
  def self.gav #Именно в таком форме мы чаще всего и будем видеть определение методов класса.
    puts 'Классовый метод gav, класс Dog (Синглтон-метод)'
  end
#Можно добавить внутрь несколько синглтон методов.Все они будут доступны k вызовy для класса Dog
  def self.name
  	puts 'Классовы метод name, класса Dog (Синглтон-метод)'
  end

#Расширить метод класс синглтон-методами можно при помощи ключивого слова class.
#Например можно поступить следующим образом.
#class << Dog #Константу Dog мы можем менять на self, это тоже допустимый способ объявления классовых методов.
  class << self #СУЩЕСТВУЕТ СОГЛАШЕНИЕ!!!Если у нас много методов класса, мы используем идеому class << self. Если у нас один синглтон метод как правило используется self.название_метода .
    def gav 
      puts 'Классовый метод gav, класс Dog (Синглтон-метод)'
    end

    def name
  	  puts 'Классовы метод name, класса Dog (Синглтон-метод)'
    end
   end
end

#def Dog.gav
  #puts 'Классовый метод, класс Dog (Синглтон-метод)'
#end

Dog.gav
Dog.name


#В руби мы можем вызывать методы цепочкой!
#Например чтобы сделать первую букву в слове заглавной воспользуемся методом capitalize
puts 'hello'.capitalize
# Eсли мы например сейчас захотим перевернуть слово мы можем воспользоваться методом reverse
puts 'hello'.capitalize.reverse
#Таким образом мы можем вызывать один метод за другим исользуя точку.
#Для того что бы нам использовать такую цепочку НАМ НЕОБХОДИМО ЧТО БЫ КАЖДЫЙ МЕТОД ВСЯКИЙ РАЗ ВОЗВРАЩАЛ ОБЪЕКТ!!!Это очнь удобно делать при помощи ключевого слова self.
# РАссмотрим это на примере класса TicketStatus
class TicketStatus #Создаем класс
	attr_accessor :status, :price
# В классе размещаем 2 инстанс переменные @status и @price.
	def initialize(price:)# Пускай у нас объект инициализируется методом initialize
	  @status = false #Если статус равен false билет доступен для продажи
	  @price = price
	end

    def buy #С помощью метода bye билет резервируется и его статус принимает значение true 
      @status = true #Если статус равен true билет уже куплен
      self # ОБРАТИТЕ ВНИМАНИЕ! Возвращается ссылка на текущий объект!Это позволяет нам сразу после метода bye вызывать какие-то другие методы данного объекта
    end
end
#Создаем объект ticketUno.
ticketUno = TicketStatus.new(price: 100.50)
#Покупаем его ticketUno.buy и тут же можем вывести цену ticketUno.buy.price
puts ticketUno.buy.price
#ТАким образом мы сами можем выстраивать цепочки ответственности, для этого достаточно возвращать ссылку на текущий объект из методов.


#Self можно возвращать из метода initialize, таким образом мы получаем возможность инициалезировать объект при помощи блока

class Ticket1
  attr_accessor :date, :price 
#Давайте уступим блок из метода initialize и передадим ссылку на текущий объект.
#Это позволит нам инициалезировать инстанс переменные @date и @price в блоке.
  def initialize
  	yield self
  end
end
#Задаём инстанс переменные в блоке.
price = Ticket1.new do |c|
  c.date = '21.12.2022'
  c.price = 150.50
end
#Выводим дамп объекта
p price ##<Ticket1:0x00007fe2fc14a4b0 @date="21.12.2022", @price=150.5>
#Как видим дамп объекта содержит инстанс переменные которые мы вывели внутри блока.




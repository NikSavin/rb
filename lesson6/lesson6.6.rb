# В ООП методы принято делить методы на открытые(public), закрытые(private) и защищенные(protected).Практически все ООП языки реализуют данную концепцию.Почему же это важно?
# Например в прошлом уроке мы говорили что метод puts реализован в модуле Kernel который подмешан на уровен класса Object.Глобальный объект main является объектом класса Object поэтому мы можем смело вызывать метод puts.
puts 'Hello World' # Hello World
# Но если ключевое слово self ссылается на текущий объект, то казалось бы мы можем указывать в качестве получателя self.Однако в этом случае мы потерпим неудачу.Дело в том что метод puts имеет закрытый метод(private),тоесть мы можем сталкиваться с закрытыми методами на уровне языка руби и ВАЖНО ПОНИМАТЬ КОНЦЕПЦИЮ ЗАКРЫТЫХ И ЗАЩИЩЕННЫХ МЕТОДОВ.
#УДАЛИТЕ КОММЕНТАРИЙ ЧТОБЫ УВИДЕТЬ ОШИБКУ! self.puts 'Hello World' #`<main>': private method `puts' called for main:Object (NoMethodError)

# Разберемся с концепцией закрытых и защищенных методов.
# По умолчанию все создаваймые методы являются открытыми.

class Ticket  # Перед нами класс Ticket у которого 2 метода price и date
  
# У метода public может быть другая форма записи.
# МЫ вызываем метод public и все что ниже его написания автоматически становиться открытой областью видимости, до тех пор пока не встретиться другой метод управляющий областью видимости, например private
# Так как методы по умолчанию практически всегда являются открытыми мы никогда не увидим метод public.
  def price # Возвращает цену билета
    #Точно так же как и с методом puts мы не можем вызывать price_format с использованием получателя self.Мы вообще не можем использовать получателя метода при вызове закрытых методов.
    #self.price_format(100.5) приведет к ошибке.Т.к. в закрытом методе мы не можем указать явно получателя!Т.е. вызывать его можно только с неявным получателем!!!
    price_format(100.5)
    #5.5
  end
# Таким образом метод price у нас будет доступен для вызова, а метод date будет закрыт.
#private # ЗАкрытыми как правило объявляют лишь те методы которые используются другими методами класса.
# Например мы можем объявить вспомогательный метод price_format который будет использоваться только в методе класса, в частности в методе price

  def date # Возвращает дату представления
    '21.04.2022'
  end
private # ЗАкрытыми как правило объявляют лишь те методы которые используются другими методами класса.
# Например мы можем объявить вспомогательный метод price_format который будет использоваться только в методе класса, в частности в методе price
# Так как метод price_format является только для внутреннего пользования и не является частью открытого интерфейса класса, мы объявляем его закрытым.
# Сигнализируем разработчикам что данный метод является только для внутреннего пользователя и может быть изменен в следующих версиях класса.
  def price_format(price)
  	format('Цена билета %.2f' , price)
  end
# Методу public мы передаем название методов которые необходимо обьявить открытыми.
  # public :date, :price
end

ticket = Ticket.new
# Мы можем обратиться к методу price через точку.
p ticket.price # Получим результат 100.5
# Обращаться к методам price и date мы можем по тому что они объявлены открыто.
# Если бы методы были по умолчанию закрытыми мы могли бы объявить их открытыми при помощи метода public.
# Давайте попробуем обратиться к методу date и убедимся что к нему нельзя получить доступ.
p ticket.date #private method `date' called for #<Ticket:0x00007fe72c81b6e8> (NoMethodError)


#Защищенные методы
#Ниже у нас представлен класс Person у которого есть attr_accessor :name и закрытый метод score.
#Мы используем данный класс для обозначения игроков в какой либо игре.У игроков есть имена и есть счет который сравнивается.

class Person
  attr_accessor :name

  def initialize(name:, score:)
  	@name = name
  	@score = score
  end

# Для сравнения создадим открытый метод compare:
# Метод принимает в качестве параметра объект другого класса Person и производит сравнение инстанс переменной @score и защищенного метода другого объекта.
# Защищенные методы мы можем вызывать внутри класса, в отличии от закрытых методов мы можем указывать для защищенных методов получатель, но получателем должен выступать либо self либо объект этого же самого класса.
  def compare(user)
  	if @score < user.score
  	  puts 'Win Alex'
  	elsif @score > user.score
  	  puts 'Win Nik'
  	else
  	  puts 'Draw'
  	end
  end


#Меняем закрытый метод private на защищенный метод protected.
  #private
  protected #private и protected можно передавать список символов.Однако предпочтительней является использованием этих методов без параметров.
# Защищенные методы нельзя вызывать за приделами класса, поэтому сравнение нам прийдется перенести сравнение внутрь класа.
  def score
  	@score
  end
end
#Создадим двух игроков.

user1 = Person.new(name: 'Nik', score: 15)
user2 = Person.new(name: 'Alex', score: 17)

#if user1.score < user2.score
#	puts 'Win Alex'
#elsif user1.score > user2.score
#	puts 'Win Nik'
#else
#	puts 'Draw'
#end
# Если мы сейчас запустим программу, то нам выдаст ошибку по тому что мы обращаемся к закрытому методу score.
# Иногда нам надо расширить облась действия закрытых методов, чтобы мы могли сравнивать 2-ва объекта одного класа друг с другом.Вот тут нам на помошь приходят защищенные методы protected.

#Посмотрим на выполнение метода compare 
puts user1.compare(user2)

#Иногда нужно закрыть или защитить методы на уровне класа.Например: Мы используем метод new для создания объекта класса, но мы можем это запретить если мы оъявим метод new закрытым.
#Давайте это попробуем это сделать.

class User #Мы создаем класс User
# Конструкция ниже достаточно большая, по этому в руби есть специальный метод private_class_method - с помощью него мы можем объявлять закрытые методы.
  #class << self #открываем класс User с помощью ключевого слова class
  	#private :new #Обьявляем классовый метод new закрытым(private)
  #end
  private_class_method :new
end
#Пытаемся создать объект класса User и убеждаемся что данный метод приводит к ошибке.
# user = User.new
#В каких случаях нам потребуется закрыть классовый метод и уж тем более закрыть конструктор?
#Такого поведения требуют некоторые паттерны
#Паттерн ФАБРИКА - Закрывает создание объекта через конструктор и создаем его при помощи специального метода.Например нам нужно проконтролировать количество создаваймых объектов или нам в зависимости от переданых параметров нужно создавать разные объекты.
#Ещё один интересный паттерн это СИНГЛТОН(не путать с синглтон-методом) - это паттерн когда у нас объект одного класса существует в единственном экземпляре.Например это соединение с базой данных которое должно быть одно или это объект с настройками сайта и не далжно быть ситуаций когда у нас будет два таких объекта, чтобы не допустить редактирования одной копии объекта, а использование другой.Для использования такого паттерна не обязательно закрывать явно наш конструктор как мы делали это в нашем классе User.Достаточно просто включить в наш класс готовый модуль Синглтон который автоматически преобретает свойства Синглтона. Чтобы воспользоваться этим модулем нам необходимо включить стандартную библиотеку данного модуля при помощи require 'singleton'
# Ниже мы попробуем создать Синглтон
require 'singleton'

class Factory
	include Singleton
end
# Видим что new является приватным методом и мы не можем им воспользоваться!
# sing = Factory.new
# p sing
# Как же нам создать новый объект в паттерне Синглтон?
# Нам нужно воспользоваться методом instance который реалезует модуль синглетон.
# Этот метод либо создает объект либо возвращает уже созданный объект.
# Давайте убедимся что при его использовании мы будем иметь дело с одним и тем же объектом.

#Мы создаем две переменные factory1 и factory2, давайте убедимся что они ссылаются на один и тот же объект.
factory1 = Factory.instance #<Factory:0x00007f9bac888930>
p factory1
factory2 = Factory.instance #<Factory:0x00007f9bac888930>
p factory2
# ЗАпускаем код и видим что мы имеем дело с одним и тем же объектом.

# Иногда требуется обойти запрет на вызов закрытых методов.Например мы с вами не можем удалить уже созданую константу.
# Т.е. если мы создаем константу HELLO и пытаемся еще раз создать такую же константу у нас будет предупреждение о том что мы пытаемся перезаписать константу: already initialized constant HELLO
                                                                                                                                                          #   previous definition of HELLO was here
HELLO = 1
# Большой соблазн перед вызовом константы в 145 строке удалить первую константу в 140 строке при помощи метода remove_const но он является закрытым, тоесть мы не можем его вызвать явно!
# Object.remove_const :HELLO #private method `remove_const' called for Object:Class (NoMethodError)
# Однако существует обходной путь для этого существует обходной метод send - метод не проверяет области видимости и определяет любой метод который мы ему передали.
Object.send(:remove_const, :HELLO)
HELLO = 2
# Давайте вывидем саму константу HELLO .
p HELLO
# Разумеется это доволно грязный прием когда мы используем напрямую закрытые методы!Их не для того закрывали что бы ими часто пользовались.
# С другой стороны это демонстрирует что закрытие и защита методов в руби довольно условна.Это вообще достаточно трудно сделать в языках ООП.
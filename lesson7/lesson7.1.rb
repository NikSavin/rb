# Enumerable - предоставляет большое количество истанс методов.Все их можно посмотреть если ввести в irb команду Enumerable.instance_methods.
# Все эти методы автоматически становяться доступными объектам класса в котором мы включаем Enumerable.
# Данный модуль включен во все коллекционные классы языка руби например в массив Array.ancestors  => [Array, Enumerable, Object, Kernel, BasicObject] 
# То же самое и с хешами Hash.ancestors => [Hash, Enumerable, Object, Kernel, BasicObject] 
# Прежде чем мы начнем знакомство с методами модуля, давайте вспомним как создаются массивы.
# Существует не так много способов создания массива.Основным способом является синтаксический конструктор - [].Мы можем прибегать и к конструктору класса Array.new .
# Конструктор класса Array позволяет задавать параметры при помощи которого мы можем указать количество элементов в массиве Array.new(3) => [nil, nil, nil].
# Также можно задавать значение по умолчанию которым будут проинициалезированны элементы Array.new(3, 0	)  => [0, 0, 0] 

# Инициалезировать элементы мы так же можем при помощи блока:
# 1) Создание массива с указанием количества элементов(3) и значение по умолчянию(Object.new) Array.new(3, Object.new) => [#<Object:0x00007f83c820e6f0>, #<Object:0x00007f83c820e6f0>, #<Object:0x00007f83c820e6f0>]
# 2) Создание массива c количеством элементов(3) при помощи блока { Object.new } Array.new(3) { Object.new } => [#<Object:0x00007f83c81ff920>, #<Object:0x00007f83c81ff8f8>, #<Object:0x00007f83c81ff8d0>] 
# В отличии от параметра Object.new блок отдельно вычисляеться для каждого элемента.Если в первом варианте у нас элементы массива указывают на один и тот же объект, во втором варианте у нас элементы ссылаются на индивидуальные объекты.

# Ещё один метод создания массива это функция Array.Обращаю внимание что функция начинается с заглавной буквы.Нарушая тем самым соглашения принятые в сообществе руби.Поэтому функцию не очень любят использовать на практике, но тем не мение она входит в состав языка.
# Array('hello') => ["hello"] 
# Действует она следующим образом:
# Если ей(функции) передается объект который поддерживает метод to_a он используеться для создания массива, если его нет используеться метод to_ary.Если нет и его, то объект просто обарачиваеться в массив как в нашем случае.

# Четвертый способ создания массива это синтасический конструктор %w[hello world] - строка которая передаеться данному конструктору разбиваеться по пробельному символу, полученные элементы становяться элементами массива ['hello','world']
# %w[hello world] => ["hello", "world"] 
# Можно также использовать другие синтасические конструкторы например %i - позволяет получить массив символов. 
# %i[hello world] => [:hello, :world] 

# Заполнять массивы можно с помощью квадратных скобок([])
# a = [] - Создаем массив
# a[0] = 2 - пишем в квадратных скобках индекс массива и присваиваем ему значение элемента-2.
# Точно так же мы можем добавить 2 элемент.Для этого мы можем использовать индекс [1].
# a[1] = 3 => 3 
# И так мы уже получаем массив из двух элементов 
# a => [2, 3]
# Не обязательно указывать промежуточные элементы!Мы можем указать сразу 10 индекс. Все промежуточные элементы получают значение nil
# a[10] = 5 => 5 
# a => [2, 3, nil, nil, nil, nil, nil, nil, nil, nil, 5] 
# Если мы попытаемся обратиться к несуществующему элементу массива мы тоже получим nil - неопределенное значение.
# a[100] => nil
# Добавить элемент в массив можно с помощью оператора сдвига( << ), новый элемент помещаеться в конец массива.
# a << 4 => [2, 3, nil, nil, nil, nil, nil, nil, nil, nil, 5, 4]
# Существует и другой способ добавления!Например можно воспользоваться методом push. Push отлечается от оператора сдвига(<<) тем что он может принимать не ограниченное количество элементов массива и добавлять их в конец массива.
# a.push 6,7,8 => [2, 3, nil, nil, nil, nil, nil, nil, nil, nil, 5, 4, 6, 7, 8] 
# Удалять элементы из массива можно с помощью метода pop. Метод возвращает последний элемент, а сам массив укорачиваеться.
# a.pop => 8
# a => [2, 3, nil, nil, nil, nil, nil, nil, nil, nil, 5, 4, 6, 7]
# Удалять первый элемент из массива можно аналогично при помощи метода shift.Действует он аналогично методу push. shift сначала возвращает первый элемент и укорачивает массив.
# a.shift => 2 
# a => [3, nil, nil, nil, nil, nil, nil, nil, nil, 5, 5, 6, 7]

# Следует обратить внимание что добавление массива в массив приводит к тому что у нас получается вложенный массив.
# a = [1, 2, 3, 4] => [1, 2, 3, 4] 
# a << [5, 6, 7, 8] => [1, 2, 3, 4, [5, 6, 7, 8]]
# Существует специальный метод flatten который позволяет убрать вложенность массивов, разворачивая внутринние массивы.
# a.flatten => [1, 2, 3, 4, 5, 6, 7, 8]
# Складывать массивы друг с другом можно при помощи метода concat. Массивы будут складываться как есть.
# [1, 2, 3].concat([2, 3, 4]) => [1, 2, 3, 2, 3, 4] 
# Вместо concat можно использовать оператор +.
# [1, 2, 3] + [2, 3, 4]=> [1, 2, 3, 2, 3, 4] 
# Поддерживаются и другие операторы, например вычитание.
# [1, 2, 3] - [2, 3, 4] => [1]
# Если при сложении массивов нам нужно получить только уникальные элементы, мы можем воспользоваться оператором объединения |. При объединении мы получаем ТОЛЬКО УНИКАЛЬНЫЕ ЭЛЕМЕНТЫ.
# [1, 2, 3] | [2,3,4] => [1, 2, 3, 4] 
# Можем получать и пересечения & в этом случае в новый массив попадают те элементы которые присутствуют и в первом и во втором массиве.
# [1, 2, 3] & [2, 3, 4] => [2, 3]
# Мы помним что false и nil в руби рассматриваються как логическая ложь, а все остальные элементы как логическая истина.
# Мы можем использовать массив как логические элементы.Например мы можем проверить все ли лементы являються истиной?Делается это при помощи метода all? .
# [true, false, true].all? => false 
# Т.к. у нас присутствует false то метод возвращает false, но эсли бы все элементы имели true нам вернулось бы true.
#[true, true, true].all => true 
# Существует еще один метод any? он возвращает true если хотябы один из элементов равен true.
# [true, false, true].any? => true 
# Если все элементы равны false, метод any? возвращает false.
# [false, false, false].any? => false 

# Существуют и более экзотические методы.Например one? который возвращает true если только один элемент равен true.
# [true, false, false].one? => true
# [true, false, true].one? => false 
# Для all? существует обратный метод это none? он возвращает false если хотябы один элемент равен true и true если все элементы равны false.
# [true, false, false].none? => false 
# [false, false, false].none? => true 
# Даная группа методов может принимать в качестве параметров блок.Внутри такого блока можно приобразовывать массивы к логическому значению.Например мы можем проверить являються ли все элементы массива числами?
# [1, 2, 3].all? {|x| Integer === x} => true # Все элементы массива являються числами.
# [1, 2, 3, 'hello'].all? {|x| Integer === x} => false # Добавляем строковое значение 'hello' и получаем false.

# ПУсть у нас есть массив цветов.Давайте проверим что хотябы один элемент массива начинаеться с g.
# %w[red yellow gray blue orange green] => ["red", "yellow", "gray", "blue", "orange", "green"] 
# %w[red yellow gray blue orange green].any? { |x| x.start_with? 'g' }  => true # Мы получаем true по тому как в массиве есть элементы gray и green.
# Давайте проверим есть ли в массиве строки с количеством символов больше 5.
# %w[red yellow gray blue orange green].any? { |x| x.size > 5 } => true # Т.к. у нас таких элементов два(orange, yellow) мы получаем true.
# А если мы заменим количество символов на 6 мы получаем false.Но метод none? должен нам вернуть true.
# %w[red yellow gray blue orange green].any? { |x| x.size > 6 } => false 
# %w[red yellow gray blue orange green].none? { |x| x.size > 6 } => true 

# Коллекции можно разбивать на отдельные подколлекции, для этого можно использовать метод each_slice().
# Создадим объёмную коллекцию для этого воспользуемся приёмом разложения диапазона [*начальный элемент диапазона...Последний элемент диапазона] и разобьем её при помощи метода each_slice на (7) элементов to_a
# [*1..21].each_slice(7).to_a => [[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21]] 

# При помощи метода include можно определять входит элемент в коллекцию или нет.
# %w[first second time].include? 'second => true # second входит в коллекцию.
# %w[first second time].include? 'tame' => false # tame не входит в коллекцию.

# При помощи метода max мы можем получать максимальный элемент коллекции при помощи метода min минимальный элемент коллекции. 
# [*1..101].max => 101 
# [*1..101].min => 1 
# существует метод minmax который позволяет получить минимальный и максимальный элемент коллекции за один раз.
# [*1..101].minmax => [1, 101] 
# Методы min, max и minmax могут получать блок в котором мы можем переопределить правила сравнение элементов.
# Например у нас есть массив строк и в качестве кретерия мы хотим выбрать максимальнo длинную строку в данном массиве.
# %w[first second time].max { |a, b| a.size <=> b.size } => "second" 

# Массив можно сортировать при помощи метода sort. Он тоже допускает блок в котором мы можем указать правила сортировки коллекции.
# [15, 16, 6, 3, 22, 505].sort => [3, 6, 15, 16, 22, 505] 
# %w[Ruby Python CSS JavaScript Swift].sort { |a,b| a.size <=> b.size } => ["CSS", "Ruby", "Swift", "Python", "JavaScript"] 

# Метод zip позволяет комбенировать массивы друг с другом.
# a = [1, 2, 3] => [1, 2, 3] 
# b = [4, 5, 6] => [4, 5, 6] 
# a.zip(b) => [[1, 4], [2, 5], [3, 6]] 
# [7, 8, 9].zip(a,b) => [[7, 1, 4], [8, 2, 5], [9, 3, 6]] 

# И массивы и хеши это отсортированные колекции, тоесть в них элементы распределються в определенном порядке.Это позволяет легко формировать одни коллекции из других.
# Например мы легко можем получит из массива хеш!Для этого мы сначала получаем массив массивов.
# %w(first second third).map.with_index { |k,i| [i,k] } => [[0, "first"], [1, "second"], [2, "third"]]
# Преобразовываем массив массивов в хэш при помощи метода to_h
# %w(first second third).map.with_index { |k,i| [i,k] }.to_h => {0=>"first", 1=>"second", 2=>"third"} 

# Хешы можно создавать при помощи синтаксического конструктора {}.Для создания мы размещаем в фигурных скобках пары - { ключь и значение }
# {"first" => "hello", "second" => "world"} => {"first"=>"hello", "second"=>"world"} 
# В качестве ключа и значения могут выступать любые объекты языка руби.очень часто в качестве ключа используються символы.
# {:first => "hello", :second => "world"} => {:first=>"hello", :second=>"world"} 
# При использовани символов в качестве ключей можно избавиться от хеш рокета ( => ). Такой интаксис более предпочтителен.
# {first: "hello", second: "world"}  => {:first=>"hello", :second=>"world"}
# для создания хеша можно использовать конструктор new класса Hash (Hash.new).
# Hash.new => {} 
# Добавлять элементы в хеш можно с помощью квадратных скобок [].
# h = Hash.new
# h['a'] = 1 => 1
# h => {"a" => 1}
# Каждый новый ключ в [] будет создавать новый элемент.
# h['b'] = 2 => 2
# h => {"a"=>1, "b"=>2} 
# Однако если мы обращаемся к уже существующему элементу, мы перезаписываем значение.Т.е. новый элемент не добавляеться, перезаписывается уже существующий.
# h['a'] = 3 => 3 
# h => {"a"=>3, "b"=>2} 
# Обращаться к лементам можно при помощи [] или при обращении метода fetch.
# h['a'] => 3 
# h.fetch('a') => 3 
# При обращении к несуществующему элементу, метод fetch возвращает исключительную ситуацию.
# h.fetch('sss')
# KeyError: key not found: "sss"
#	from (irb):77:in `fetch'
#	from (irb):77
#	from /Users/test123/.rvm/rubies/ruby-2.4.2/bin/irb:11:in `<main>'
# При использовании [] мы просто получаем значение nil
# h['sss'] => nil
# Метод fetch может принимать дополнительныe параметры.Например мы можем добавить значение по умолчанию.
# h.fetch('sss', 0) => 0 
# В этом случае при обращении к несуществующему элементу будет приводить к тому что он будет возвращать значение второго параметра, а не возбуждать исключительную ситуацию.
# Хеши можно объединять при помощи метода merge.
# h1 = {first: "Hello", second: "World"} => {:first=>"Hello", :second=>"World"} 
# h2 = {hello: "First", world: "Second"} => {:hello=>"First", :world=>"Second"} 
# h1.merge h2 => {:first=>"Hello", :second=>"World", :hello=>"First", :world=>"Second"} 

# Все методы Enumerable доступны и для хешей. Однако надо помнить что сравниваются фактически массивы из двух элементов это ключ и значение.
# Если мы хотим применить какой нибудь метод Enumerable к хешу(получение min, max, sort и т.д.) нам часто следует использовать блок в котором следует явно определить логику сортировки коллекции.
# Например мы можем поискать максимальное значение по КЛЮЧУ используя первый элемент.
# h1 = {first: 2, second: 1} => {:first=>2, :second=>1} 
# h1.max {|a, b| a.first <=> b.first} => [:second, 1] # Буква s находится в алфавите дальше чем буква f поэтому в качестве максимального значения был выбран ключ second.
# Однако если мы воспользуемся методом last, т.е. возьмем ЭЛЕМЕНТЫ коллекции то максимальным значением будет цифра 2.
#h1.max {|a, b| a.last <=> b.last} => [:first, 2] 

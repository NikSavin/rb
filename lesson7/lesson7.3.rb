# Регулярные выражения это специалезированый язык шаблонов, который позволяет искать, заменять и удалять подстроки в строках.
# Фактически это отдельный язык программирования, только в отличии от Ruby он не являеться универсальным.
# Регулярные выражения это всегда часть какого то другого языка пограммирования.
# Регулярные выражения существуют достаточно давно, однако в современной форме они сформировались в языке Perl.Практически все языки программирования реалезуют Perl вариант регулярных выражений!

# Ruby поддерживает большое количество методов которые предназначены исключительно для обслуживания регулярных выражений(=~, match, match?, grep, scan)
# Для создания регулярных выражений существует специальный синтаксический конструктор //

# Используем irb  
# // => // # Полученный объект являеться регулярным выражением.
# //.class => Regexp # Можно посмотреть класс регулярного выражения.
# Можно использовать класс Regexp для создания регулярного выражения при помощи конструктора .new
# Regexp.new => ArgumentError: wrong number of arguments (given 0, expected 1..3)
# Как видим конструктор требует дополнительных параметров. Передадим ему пустую строку чтобы получить пустое регулярное выражение.
# Regexp.new'' => // 
# К классу Regexp практически никогда не прибегают.Чаще используеться конструктор // .
# Между двумя слэшами // можно поместить регулярное выражение.Давайте найдем подстроку в спомощью регулярного выражения.
# 'Язык программирования Ruby' =~ /Ruby/ => 22 #Мы обнаружили строку Ruby на 22 позиции.
# 'Hello world' =~ /Ruby/ => nil # Если подстрока не будет найдена, то оператор вернет значение nil.
# Вместо оператора =~ можно использовать метод match если мы хотим получить результирующий объект.
# 'Язык программирования Ruby'.match  /Ruby/ => #<MatchData "Ruby"> # Получаем результирующий массив который можем сохранить в отдельной переменной.
# m = 'Язык программирования Ruby'.match  /Ruby/ => #<MatchData "Ruby"> 
# m.to_a => ["Ruby"] # Переменная поддерживает метод to_a для преобразования в обычный массив.Таким образом  мы можем получить найденные результаты.

# Пока продемонстрированные возможности регулярных выражений не очень велеки.Связано это с тем что мы практически не используем их возможности.ДАвайте познакомимся с некотороми элементами регулярных выражений. В первую очередь с метасимволами.
# Если мы используем метод точки .Это в свою очередь означает любой символ.
# [] можно использовать диапазоны.Можно выбрать символы из определенного диапазона.
# Можно привязать регулярное выражение к строкам с поможью символов ^,$,\,\
# Можно использовать различныеварианты используя логическое | - или.
# (...) Можно группировать символы при помощи.
# 'Hello'.match /l./ => #<MatchData "ll"> # Находим символ l и следующий символ после него.
# 'world'.match /l./ => #<MatchData "ld"> # 
# Мы можем указывать и диапазоны символов:
# '500'.match /[56]00/ => #<MatchData "500">  # Данное выражение будет соответствовать и числу 500 и числу 600.
# '600'.match /[56]00/ => #<MatchData "600"> 
# Но для числа 700 это выражение уже действовать не будет.
# '700'.match /[56]00/ => nil 
# Привязываться можно и к границам слов:
# 'Hello world'.match /world/ => #<MatchData "world"> 
# МЫ можем привязать слово world к началу строки при помощи символа ^ :
# 'Hello world'.match /^world/  => nil # Ничего не найдено т.к. в начале строки идет слово Hello
# 'world Hello world'.match /^world/ => #<MatchData "world"> # Теперь наше выражение работает.
# Можно привязываться к концу строки при помощи символа $ :
# 'world Hello world'.match /world$/ => #<MatchData "world"> 

# Следует внимательнее относиться к многострочным выражениям.
# ПУСТЬ У НАС ЕСТЬ СТРОКА НА КОТОРЫХ СЛОВО Hello и world расположены на разных строках.
# str = <<here
# Hello
# world
# here
# => "Hello\nworld\n" 
# Если мы привяжемся к концу строки то мы получим результат:
# str.match /Hello$/ => #<MatchData "Hello"> 
# str.match /world$/ => #<MatchData "world"> 
# Дело в том что конец строки совпадает с символом \n - экранированным символом переводом строки.
# Если мы хотим привязаться к окончанию всего выражения Hello world нам потребуеться воспользоваться символом \z единственное нам потребуеться явно указать перевод строки \n
# str.match /world\n\z/ => #<MatchData "world\n"> 
# str.match /Hello\n\z/ => nil 
# Для привязки к началу нужно использовать экранированный символ \A
# str.match /\AHello$/ => #<MatchData "Hello"> # Так мы можем привязаться к началу выражения.

# При помощи вертикальной черты | мы можем привязаться к конструкции 'или' :
# Пускай у нас есть фраза 'Hello world' и есть фраза 'Hello ruby' и пускай требуется написать выражение которое будет искать слово world или слово ruby:
# "Hello world".match /Hello (world|ruby)/ => #<MatchData "Hello world" 1:"world">
# "Hello ruby".match /Hello (world|ruby)/ => #<MatchData "Hello ruby" 1:"ruby"> 
# Обратите внимание как изменился результирующий объект MatchData в нем найденно полное соответствие "Hello world", "Hello ruby" и содержимое круглых скобок "world", "ruby". Дело в том что круглые скобки выступают своеобразными "кармашками" в которых мы можем сохранять промежуточные результаты.
# Если нас интересует содержимое только круглых скобок мы можем воспользоваться методом scan который сразу вернет массив массивов с элементами в скобках.
# "Hello ruby".scan /(Hello) (world|ruby)/ => [["Hello", "ruby"]] 
# Scan может обнаружить несколько вариантов которые подходят под регулярные выражения.
# "Hello ruby Hello ruby".scan /(Hello) (world|ruby)/ => [["Hello", "ruby"], ["Hello", "ruby"]] 

# Слэш предает символам специальное значение.Без символа экранирования они означают сам символ.Если сиволы экранировать они получают специальные значения :
# \b -- граница слова
# \t -- один символ из диапазона
# \r -- символ возврата каретки
# \d -- символ числа
# \n -- символ перевода строки
# \w -- символ слова
# \s -- пробельный символ
# И наобарот - Специальные символы будучи экранироваными обозначают сами себя.
# Например знак $ у нас имеет специальное значение, но если нам нужно будет найти его в строке мы можем воспользоваться экранированием.
# При помощи такого регулярного выражения мы можем извлечь стоимость указаную в долларах:
# "Цена билета $50".match /\$\d\d/ => #<MatchData "$50"> # Символ \d здесь обозначает любую цифру.Что бы извлечь число 5 и 0 нам понадобилось два раза указать \d.
# "Цена билета $500".match /\$\d\d/ => #<MatchData "$50"> # Если наша цена будет $500 а мы укажем два символа d (\d\d) то мы попрежнему будем извлекать только $50.
# "Цена билета $500".match /\$\d\d\d/ => #<MatchData "$500"> # Чтобы все работало верно, нам нужно указать три символа \d\d\d  чтобы извлекать правильную сумму.

# Для примера выше нам полезен механизм который позволял бы извлекать символы произвольной длины. 
# Чтобы символы произвольной длины придуманны КВАНТИФИКАТОРЫ.
# КВАНТИФИКАТОРЫ изменяют количество вхождений предыдущего символа или сгруппированного выражения( выражения которое мы помещаем в круглые скобки () ).
# ? -- один или ноль вхождений
# * -- ноль или несколько вхождений
# + -- одно или несколько вхождений
# {n} -- ровно n вхождений
# {n,} -- больше n вхождений
# {n,m} -- от n до m вхождений
# Попробуем изменит наш пример с помощью квантификаторов.
# Можем изменить выражение с тримя символами \d\d\d можем заменить на выражение \d+ :
# "Цена билета $500".match /\$\d+/ => #<MatchData "$500"> 
# Либо явно указав количество цифр которое мы можем извлечь с помощью {n} :
# "Цена билета $500".match /\$\d{3}/ => #<MatchData "$500"> 
# Данное сверху выражение не сработает для $50 поэтому мы можем указать диапазон от 1 до 3 цифр {1,3}
# "Цена билета $50".match /\$\d{3}/ => nil 
# "Цена билета $50".match /\$\d{1,3}/ => #<MatchData "$50">
# Вместо экранированного символа \d мы можем указывать диапазон например - [0-9].Просто символ \d более компактен.
# "Цена билета $500".match /\$[0-9]{1,3}/ => #<MatchData "$500"> 
# Символы можно помещать и внутрь квадратных скобок [], более того мы могли бы поместить туда и символ $ :
# "Цена билета $500".match /[\$\d]+/ => #<MatchData "$500"> 

# Пусть имеется фраза "Цена билета 500 рублей". Давайте извлечем из неё стоимость билета :
# "Цена билета 500 рублей".match /\d+/ => #<MatchData "500"> 
# Можно так же воспользоваться квадратными скобками []
# "Цена билета 500 рублей".match /[\d]+/ => #<MatchData "500"> 
# В [] мы можем использовать не только диапазоны, но и отрицательные диапазоны.
# Для примера найдем чать выражения в которых нет чисел для этого мы используем символ ^ :
# "Цена билета 500 рублей".match /[^\d]+/ => #<MatchData "Цена билета "> #Мы получаем "Цена билета" , далее идут цифры и регулярное выражение прекращает поиск.
# Что делать если нам нужно извлечь какое либо слово?Давайте найдем любое слово которое не являеться цифрой или пробелом.
# Мы могли бы работать с отрицаниями добавив в наше выражение просто пробельный символ \s и получили бы просто слово "Цена" :
# "Цена билета 500 рублей".match /[^\d\s]+/ => #<MatchData "Цена">
# Мы можем указать диапазон букв русского алфавита.Мы указываем диапазоны для заглавных и строчных букв.
# "Цена билета 500 рублей".match /[А-Яа-я]+/ => #<MatchData "Цена"> 
# Если мы вместо квантификатора + воспользуемся {n,} мы можем получить слово от 5 символов

# При помощи регулярных выражений можно ззаменять и удалять подстроки в строках, разбивать строки на фрагменты, извлекать содержимое соответствующиее круглым скобкам и строить комбинации из этих фрагментов.
# Многие методы в руби поддерживают регулярные выражения.Например методы sub и gsub могут заменять как отдельные строки так и строки найденые при поможи регулярных выражений.Тоже самое касаеться и split, он может принимать как отдельную строку так и регулярное выражение.
# sub -- однократная замена в строке
# gsub -- многократная замена в строке
# split -- разбивает строку на массив подстрок

# Пусть у нас есть фраза: "Цена билета 500 рублей".Заменим в ней подстроку 500 на 600.
# Воспользуемся для этого методом sub:
# "Цена билета 500 рублей".sub(/500/,'600') => "Цена билета 600 рублей" 
# sub заменяет только первое вхождение.Например у нас есть другой билет с двумя ценами 500 и 600.
# "Цена билета увеличелась с 500 на 600 рублей".sub(/\d+/,'700') => "Цена билета увеличелась с 700 на 600 рублей" 
# Мы получаем строку в которой заменена первая попавшаяся цифра.Если мы воспользуемся методом gsub заменены будут все вхождения цифр.
# "Цена билета увеличелась с 500 на 600 рублей".gsub(/\d+/,'700') => "Цена билета увеличелась с 700 на 700 рублей" 
# Методы sub и gsub принимают блок, мы можем в них явно  указать условия при которых должны изменять значения в строке.
# Давайте в строке "Цена билета увеличелась с 500 на 600 рублей" изменим значение с 600 на 700 рублей, для этого воспользуемся блоком.
# Мы заменяем найденную подстроку только в том случае если полученая цифра больше 600 в противном случаем мы оставляем её без изменений.
# "Цена билета увеличелась с 500 на 600 рублей".gsub(/\d+/) {|x| x.to_i >= 600 ? 700 : x} => "Цена билета увеличелась с 500 на 700 рублей"
# Таким образом условие в блоке не соответствовало цифре 500 и она осталась без изменений, а 600 рублей увеличилась до 700.
# Методы sub и gsub можно также использовать для удаления подстрок.Например давайте вырижем все цифры из строки.Для этого мы схождения заменяем просто пустой строкой.
# "Цена билета увеличелась с 500 на 600 рублей".gsub(/\d+/, " ") => "Цена билета увеличелась с   на   рублей" 

# Далее рассмотрим использование метода split которое разбивает строку на массив подстрок по регулярному выражению.
# Давайте укажем любое количество пробельных символов (\s+) и в результате получим массив подстрок.
# "hello ruby  world".split /\s+/ => ["hello", "ruby", "world"] 

# Посмотрим несколько примеров.Например: "Цена билета 500.00 рублей".В данном случае мы имеем не просто число 500, а число 500.00 с плавающей точкой.
# Попробуем извлечь сумму 500.00 до копеек:
# 1) Начинаем с регулярного выражения(//), 
# 2) Извлекаем цифры до точки(\d+ - диапазон \d указывает цифры от 0 до 9. + указывает на произвольное количество символов, сделано это для того чтобы у нас подходило и 500, и 5000, и 5.)
# 3) Далее нам надо указать символ(.) [,.]. Здесь мы перестраховались и на всякий случай добавили(,) если вдруг редактор ошибеться и будет использовать вместо(.), (,) .
# 4) После этого мы указываем произвольное количество символов после точки или запятой [,.] \d+.
# "Цена билета 500.00 рублей".match /\d+[,.]\d+/ => #<MatchData "500.00"> 

# Давайте извлечем дату из строки: "Дата представления 28.12.2022"
# 1) Первое у нас идет число месяца оно может быть указано в формате 01 или просто 1, поэтому следует указать диапазон чисел {1,2}.
# 2) Далее мы воспользуемся экранированием точки \. чтобы регулярное выражение понимало что мы ожидаем увидить точку,а не любой символ.
# 3) В месяце тоже воспользуемся диапазаном (\d{1,2}),т.к. до октярбя(10) месяц содержит одну цифру(сентябрь 9 месяц).
# 4) Далее следует опять экранирование точки \.
# 5) Год у нас всегда содержит четыре символа поэтому диапазон вводить не нужно \d{4}.
# "Дата представления 28.12.2022".match /\d{1,2}\.\d{1,2}\.\d{4}/ => #<MatchData "28.12.2022"> 

# Для удобства можно было бы поместить каждую цифру в круглые скобки, для того чтобы каждую цифру извлекать отдельно.
# "Дата представления 28.12.2022".match /(\d{1,2})\.(\d{1,2})\.(\d{4})/ => #<MatchData "28.12.2022" 1:"28" 2:"12" 3:"2022"> 

# Более того можно сразу преобразовать объект MatchData в массив.
# "Дата представления 28.12.2022".match(/(\d{1,2})\.(\d{1,2})\.(\d{4})/).to_a => ["28.12.2022", "28", "12", "2022"] 
# Значения в курглых скобках можно именовать с помощью знака (?) !
# m = "Дата представления 28.12.2022".match(/(?<day>\d{1,2})\.(?<manth>\d{1,2})\.(?<year>\d{4})/) => #<MatchData "28.12.2022" day:"28" manth:"12" year:"2022"> 
# Как видно в объекте MatchData результаты именованны.Обратиться к ним можно используя символы year, manth, day используя их в квадратных скобках.
# m[:day] => "28" 
# m[:year] => "2022" 

# Можно не только удалять или извлекать выражения.Можно также преобразовывать найденные значения.
# Допустим есть строка с электронным адресом, давайте заменим в данной строке вхождение электронного адреса на тег a (<a href=''> </a>)который в браузере подсветит email ссылкой щелчек по которой будет преводить к открытию окна в почтовой программе.
# "Мой электронный адрес some@gmail.com"
# 1) Поместим выражение в переменную str
# 2) Подберем регулярное выражение (//) емайл указывается на английском языке поэтому мы используем диапазон символов от a до z и цифры от 0 до 9, используем подчеркивание(_), символ минус (-)который мы выносим вперед чтоы он не рассматривался как какой-то диапазон и кроме того используем точку(.)[-0-9a-z_.] .Нам нужно произвольное количество символов поэтому мы указываем квантификатор + [-0-9a-z_.]+ .
# 3) Указываем @
# 4) Далее следует указать такое же выражение как и в пункте 3. [-0-9a-z_.]+
# 5) указываем точку \.
# 6) и последнне остаеться выражение для домена первого уровня [a-z]{2,6}
# str.match(/[-0-9a-z_.]+@[-0-9a-z_.]+\.[a-z]{2,6}/) => #<MatchData "some@gmail.com"> 
# Заменим наш электронный адрес на слово email:
# str.gsub /[-0-9a-z_.]+@[-0-9a-z_.]+\.[a-z]{2,6}/, 'email' => "Мой электронный адрес email" 
# Теперь вместо email укажем тег а.Для того чтобы подставить найденный email в строку замены мы можем использовать специальный синтаксис \\0
# str.gsub /[-0-9a-z_.]+@[-0-9a-z_.]+\.[a-z]{2,6}/, "<a href='\\0'>\\0</a>" => "Мой электронный адрес <a href='some@gmail.com'>some@gmail.com</a>" 
# Таким образом найденное выражение будет подставленно как внутри тега а (some@gmail.com) так и внутри атрибута <a href='some@gmail.com>
# Если в регулярном выражении используються круглые скобки то вместо 0 мы можем использовать 1,2,3 которые соответствуют порядку вхождения круглых скобок, т.е. 0 соответствует всему регулярному выражению, а цифры 1,2,3 всем последующим скобкам.
# Давайте заключим имя в нашем емейле в круглые скобки и заменим 0 на 1. Таким образом мы получаем только имя из емайла.Только то чему соответствуют первые круглые скобки.
# str.gsub /([-0-9a-z_.]+)@[-0-9a-z_.]+\.[a-z]{2,6}/, "<a href='\\1'>\\1</a>" => "Мой электронный адрес <a href='some'>some</a>" 
# В этом уроке вспомним что такое блоки и убедимся что блок это тоже объект.Познакомимся с лямбда функциями и посмотрим отличия прок объектов от лямбды. 

# прежде всего вспомним что такое блок и как он создаёться.Проще всего создать блок при помощи метода yield.
# Пускай у нас есть метод iter в теле которого вызываеться ключивое слово yield.Это означает что метод iter может принимать блок.
def iter
 yield
end
# Давайте передадим методу iter какой-то блок.
iter { puts 'Hello world' }
# Как деуствуют блоки? Когда мы вызываем метод iter мы переходим внутрь метода.
# Там мы вызываем ключивое слово yield которое уступает вычисление блоку и мы перемещаемся внутрь блока { puts "Hello world" } где происходит вывод сообщения puts "Hello world".
# После того как блок отработал мы возвращаемся внутрь метода item и вычисления продолжаються далее до конца метода.
# Границы блока можно обазначать не только фигурными скобками {}, но и ключивыми словами do ... end это тоже допустимая форма записи блока.

# Блоки тоже могут возвращать значения.В блоке сверху значение возвращает nil это связанно с тем что имено такое значение возвращает метод puts и оно является результатом работы блока.
# def item
# 2.4.2 :002?>   yield
# 2.4.2 :003?>   end
# => :item 
# 2.4.2 :004 > item { puts "Hello world" }
# Hello world
# => nil 
# Однако мы можем добавить в последнее выражение item { puts "Hello world" } например: "мы внутри блока".Оно будет возвращено yield и так как ключивое слово yield являеться последним выражением метода iter оно будет возращено этим ключивым словом.
# 2.4.2 :006 > item { puts "Hello world"; 'Мы внутри блока' }
# Hello world # Данную строчку выводит метод puts 
# => "Мы внутри блока" # Метод iter ВОЗВРАЩАЕТ РЕЗУЛЬТАТ ВЫЧИСЛЕНИЯ БЛОКА, строку "Мы внутри блока".
# БЛОКИ В ЯЗЫКЕ РУБИ ЯВЛЯЮТСЯ ОБЪЕКТАМИ ОНИ МОГУТ СОХРАНЯТЬ СОСТАЯНИЕ, В ОТЛИЧИИ ОТ МЕТОДОВ КОТОРЫЕ ХРАНИТЬ СОСТОЯНИЕ НЕ СПОСОБНЫ

# Объект блока имеет класс Proc, именно поэтому объекты которые представляют блоки часто наывают proc объектами.
# Если имееться класс мы можем воспользоваться конструктором и присвоить объект какой либо переменной.Давайте так и поступим.
# 2.4.2 :007 > pr = Proc.new { puts 'Hello world' }
#  => #<Proc:0x00007fbd340e1db8@(irb):7> 
# Выше мы создали точно такой же объект как и ранее.Мы можем вызвать вычисление если воспользуемся методом call этого объекта.
# 2.4.2 :008 > pr.call
# Hello world
# => nil 

# Передавать блоки можно явно если мы воспользуемся синтаксисом с использованием специального символа - амперсанд (&).
# У метода может быть только один параметр с использованием &.
def some(&block) 
#Здесь параметр block являеться proc object поэтому мы можем вызвать у него метод call.
  block.call
end
# Если мы можем явно создать блок это значит что мы можем присвоить его отдельной переменной.
 prc = Proc.new { puts 'Мы внутри блока Proc' }
# Для того чтобы воспользоваться блоком мы так же воспользуемся символом &.
 some(&prc)

# Некоторые объекты имеют метод to_proc которые позволяют получить proc объекты.
# Например метод символа: если у нас есть метод символа to_s мы можем преобразовать его в прок объект(:to_s.to_proc).
# 2.4.2 :027 > :to_s.to_proc
# => #<Proc:0x00007fbd350a27e8(&:to_s)> 
#  Для этого существует сокращенная форма.Например когда мы пользуемся итераторами мы используем ссылку на символы для которых автоматически вызывается метод to_proc.Таким образом вместо блока мы можем использовать параметр и сократить выражение которое вызывает итератор.
# [1,2,3].map(&:to_s) 
# => ["1", "2", "3"] 
# Мы можем любой объект научить вести себя как proc объект если реализуем в нем метод to_proc.
# Пусть у нас имеется класс Person, у которого есть attr_accessor :name. Давайте внутри него реализуем метод to_proc который будет возвращать proc объект.
class Person
  attr_accessor :name
# реализуем метод to_proc
  def self.to_proc
  	Proc.new { |person| person.name }
  end
end
# Создадим массив состоящий из объектов данного класса:
i = Person.new
i.name = 'Ivan'
a = Person.new
a.name = 'Alex'
p [i, a]
puts '=========================='
# Запускаем программу и видим что у нас есть два объекта класса Person:
# #<Person:0x00007ff13996d638>
# #<Person:0x00007ff13996d5e8>
# Мы можем использовать любой итератор, например map для преобразования массива и указать в качесте бъекта класс Person.
# Для Person автоматически будет вызываться метод to_proc.
# Давайте убедимся что сейчас мы получим массив имён:
p [i, a].map(&Person)
# Мы можем использовать любой другой proc объект.
# Создадим proc объект который выводит переданный ему элемент заглавными буквами.
# 2.4.2 :030 > pr = Proc.new { |x| puts x.upcase }
# => #<Proc:0x00007fbd3409f440@(irb):30> 
# Пусть у нас есть массив имен к которому мы хотим применить данный proc объект.
# 2.4.2 :031 > %w[Igor Ivan]
# => ["Igor", "Ivan"] 
# Мы можем воспользоваться методом each и через & передать блок итератору each. И мы получим список имен заглавными буквами.
#  %w[Igor Ivan].each(&pr)
# IGOR
# IVAN
# => ["Igor", "Ivan"] 

# Proc oбъекты могут выступать  в качестве замыканий.Замыкание это способность захватывать значения в момент вызова. 
# У нас есть метод multiply_by, который создает внутри себя прок объект Proc.new 
# def multiply_by(m) # Мы передаём методу multiply_by параметр m и в момент создания прок объекта(mult = multiply_by(10)), параметр m(10) сохраняеться внутри объекта.
#  Proc.new { |x| puts x * m}
# end 
# mult = multiply_by(10) # Если мы передали в наш метод значение 10. то и объект прок который будет возвращен методом multiply_by будет хранить в себе состояние 10.
# После того как мы принимаем решение вызвать call прок объект mult уже знает что в него сохранено значение 10.Поэтому мы получим результат 120.
# mult.call(12)
# Если мы сейчас создадим mult1 и сохраним в него новое значение. То каждый прок объект будет помнить свое собственное значение.
# mult1 = multiply_by(100)
# mult1.call(6)

# Захватывать объекты можно не только внутри метода, но и в глобальной области видимости.
# При создании метода мы захватываем нашу переменную "а" за пределами блока, она получает значение "а в блоке"
def some(n)
  a = 'a внутри метода'
  puts a # а внутри метода
  n.call # а в блоке
end
# 
a = 'a в блоке'

pr = Proc.new { puts a }
# Вызываем блок и в данном случае мы получаем значение "а в блоке".
pr.call
# Передаем переменную pr внутрь метода.
some(pr)
# Разберем результат в консоли.
# a в блоке # Переменная а в глобальной области
# a внутри метода # Переменная а внутри метода
# a в блоке # Вызов блока внутри метода приводит к выводу захваченного значения "а" в блоке { puts a }

# Помимо блоков существует еще вызов лямбда функций они создаються при помощи ключивого слова lambda.
lm = lambda { puts 'Это lambda!' }
p lm
# Лямбда очень похожи на блоки, фактически это тоже разновидности прок объекта.
# Например мы можем вызвать лямбду при помощи метода call
lm.call
# Однако СУЩЕСТВУЮТ ОТЛИЧИЯ прок объектов и лямбда функций:
# 1) Это реакция на return. При вызове return внутри лямбды мы покидаем лямбду но не покидаем метод.Если мы вызываем return внутри прок объекта, мы покидаем текущий метод.
def return_test
  l = lambda { return }
  l.call # Вызов лямбды не прекращает работу метода return_test
  puts 'Lambda ещё тут.'

  pr = proc { return }
  pr.call # Вызов метода call для прок объекта приводит к прекращению выполнения тела метода return_test.
  puts 'Proc вышел из метода. Это сообщение мы никогда не увидим.'
end
# Запускаем программу и видим что лямбда вернула результат из блока в то время как прок вернул результат из всего метода.
return_test

# по аналогии с лямбда для прок объектов есть ключивое слово proc.Оно полность эквивалентно конструктору Proc.new
# pr = proc { puts 'Это прок объект' }
# pr = Proc.new { puts 'Это прок объект' }
# Блоки могут принимать параметры.Например ниже мы передаем в блок параметр х который тут же выводим при помощи метода p.
# pr = proc { |x| p x }
# Если мы сейчас воспользуемся методом call мы должны передать ему какой либо параметр.
# pr.call('1')
# pr.call(1)
# 1
# => 1 
# Если мы не передадим ему никакой параметр, значение х получит неопределенное значение.
# pr.call()
# nil
# => nil 
# Так же мы можем передать неопределенное количество параметров.Будет использоваться только первый!
# pr.call(1, 2, 3)
# 1
# => 1 

# Lambda функции видут себя по другому!Создадим точно такую же лямбду.
# lm = lambda { |x| p x }
# Если мы захотим ее вызвать мы должны передать ей один параметр.
# lm.call(1)
# 1
# => 1 
# Если мы попробуем ее вызвать без параметров мы получим ошибку.
# lm.call()
# ArgumentError: wrong number of arguments (given 0, expected 1) # Метод call ожидает 1 параметр, а переданно 0 .
# Это еще одно отличие лямбда от прок объектов.
# Для лямбда существует сокращенный стрелочный синтаксис ->. Мы получаем переменную которая ссылаеться на лямбду вызвать которую мы можем при помощи метода call.
# lm = -> {puts 'Это тоже Lambda'}
# lm.call
# Это тоже Lambda
# => nil 
# Если нам потребуеться указать параметры то нам потребуеться задать их после стрелочки -> в скобках () через запятую (x, y)
# lm = ->(x, y) {x * y } # Умножаем два числа которые передаються в параметры лямбда.
# => #<Proc:0x00007f83ffa05110@(irb):62 (lambda)> 
# При вызове метода call мы обязаны указать два параметра.
# В данном уроке мы будем использовать файл tickets.txt 
# Для того чтобы начать работать с файлом его нужно сначала открыть и получить файловый дискриптер, объект класса файл.
# Мы указываем конструктору имя файла для того чтобы конструктор смог его обнаружить следует указать либо относительное либо абсолютный путь к файлу:
# Так как мы запустили наш irb непосредственно из папки с файлом нам не нужно указывать путь.
# f = File.new('tickets.txt') => #<File:tickets.txt>  # Мы получили файловый дескриптер

# Прочитать содержимое файла можно при помощи read:
# f.read => "Цена билета: 500\nДата: 22.02.2022\nМесто: 3 ряд, 10 место"
# read выводит файлы в виде одной строки, с символами переноса строки \n.

# Для чтения каждой строки отдельно мы можем использовать метод gets.
# f.gets => "Цена билета: 500\n" # Читает первую строку
# f.gets => "Дата: 22.02.2022\n" # Вторая строка
# f.gets => "Место: 3 ряд, 10 место" # Третья строка
# f.gets => nil # В нашем файле больше нет строк по этому метод gets выводит nil

# Для определения состояния конца файла сеществует специальный метод eof он определяет true когда мы достигли конца файла и false когда в файле еще есть строки.
# f.eof? => true # Т.к. в примере выше мы достигли значения nil(конец файла) поэтому наш метод eof? выводит true.

# Построчно читать содержимое файла можно при помощи метода readline 
# f.readline => "Цена билета: 500\n" 
# f.readline => "Дата: 22.02.2022\n" 
# f.readline => "Место: 3 ряд, 10 место" 
# Если мы доходим до конца файла возникает исключение.
# f.readline => EOFError: end of file reached

# Если мы вызовем метод ancestors в отношении класса File мы обнаружим что в списке наследственности есть модуль Enumerable.
# File.ancestors => [File, IO, File::Constants, Enumerable, Object, Kernel, BasicObject]
# Модуль Enumerable позволяет нам воспользоваться файлом как колекцией.Например мы можем прочитать строки при помощи итератора each.
# f.each { |line| puts line }
# Цена билета: 500
# Дата: 22.02.2022
# Место: 3 ряд, 10 место
# => #<File:tickets.txt> 
# Более того мы можем воспользоваться итератором each_with_index который позволяет пронумеровать строки.
# f.each_with_index { |line, i| puts "#{i + 1}. #{line}" } # Блок принимает два параметра.
# 1. Цена билета: 500
# 2. Дата: 22.02.2022
# 3. Место: 3 ряд, 10 место
# => #<File:tickets.txt> 

# Если нам необходимо полное содержимое файла, можно использовать синглитон методы класса File.
# Т.е. мы не открываем файл, а сразу используем метод read:
# File.read('tickets.txt') => "Цена билета: 500\nДата: 22.02.2022\nМесто: 3 ряд, 10 место"  
# Если нам необходимо получить массив строк то нам нужно воспользоваться методом readlines:
# File.readlines('tickets.txt') => ["Цена билета: 500\n", "Дата: 22.02.2022\n", "Место: 3 ряд, 10 место"] 
# Обратим внимание что в массиве присутствуют символы перевода строк(\n).От них можно избавиться если использовать метод chomp.
# Так можно почистить строки которые возвращает метод readlines:
# File.readlines('tickets.txt').map(&:chomp) => ["Цена билета: 500", "Дата: 22.02.2022", "Место: 3 ряд, 10 место"] 

# Для того чтобы записать что-то в файл, его необходимо открыть в режиме записи.Для этого конструктору класса new передаеться дополнительный параметр - w
# Давайте создадим отдельный файл data_out для того чтобы не перезаписывать наш файл tickets.
f = File.new('data_out', 'w')
# Записать данные можно при помощи метода puts который нам очень хорошо знаком.Только в качестве получателя метода будет выступать объект f класса File.
f.puts('Цена билета равна 500$.')
# Строго говоря после того как вы открыли файл и поработали с ним его нужно закрыть при помощи метода close.Мы не использовали его ранее так как файл автоматически закрывался руби после того как программа отрабатывала.
# Однако при записи метод close преобретает специальное значение.Дело в том что информация которая записываеться в файл не сразу попадает на жесткий диск, она сохраняется в буфере.
# Для того чтобы содержимое буфера гарантированно было записанно на жесткий диск ФАЙЛ ЛУЧШЕ ЗАКРЫТЬ ЯВНО.
f.close
# Запускаем программу на выполнение (ruby lesson7.5.rb) и теперь мы можем посмотреть содержимое нашего файла.
# Чтобы посмотреть содержимое файла в терминале можно воспользоваться командой: cat ИМЯ_ФАЙЛА
# cat data_out
# Цена билета равна 500$.

# Если мы сейчас попробуем записать в наш файл информацию повторно, то все строки буду удалены.Дело в том что файловый дескриптор когда мы записываем строки находится в начале. 
# Для того чтобы переместить дескриптор явно в конец файла, необходимо открыть файл в режиме ДОЗАПИСИ.
# Чтобы открыть файл в режиме дозаписи необходимо передать в качестве второго пораметра в конструктор File необходимо передать строку 'a' :
f = File.new('data_out', 'a') # Открываем файл на дозапись.
f.puts ('Дата проведения: 28.02.2022') # Метод puts автоматически добавляет перевод строки(\n) после каждой записи, поэтому явно его добавлять нет необходимости.
f.close # Закрываем файл
# Запускаем программу на выполнение (ruby lesson7.5.rb)
# Просматриваем cодержимое нашего файла при помощи cat и видим что у нас появилась вторая строка с датой мероприятия :
# cat data_out
# Цена билета равна 500$.
# Дата проведения: 28.02.2022

# Чтобы явно не закрывать наш файл можно воспользоваться блоком, выход из блока служит сигналом закрытия файла.
File.open('tickets.txt') do |f|
#  ДАвайте построчно обойдём файл.
# Переменная record будет построчно выводить файл с помощью метода gets
  #while record = f.gets 
# Чаще всего мы будем видеть обход файла с помощью итератора each.Запустим программу на выполнение и видим что результаты не поменялись.
  f.each do |record|
# Почистим нашу строку с помощью метода chomp и разобъем её на ключь и значение 
   key, value = record.chomp.split(':')
   puts "#{key} => #{value}"
  end
end
# Цена билета =>  500
# Дата =>  22.02.2022
# Место =>  3 ряд, 10 место

# При работе с файлами генерируеться очень много исключительных ситуаций.
# Например при обращении к несуществующему файлу мы видим вот такую ситуацию:
# File.readlines('data_out1').map(&:chomp)
# Errno::ENOENT: No such file or directory @ rb_sysopen - data_out1
# Так же мы получаем исключение при недопустимых операциях.
# Например мы можем открыть с вами какую либо дирректорию и попытаться прочитать из нее информацию.Это приведет к исключительной ситуации.
# f = File.open('/tmp')
# => #<File:/tmp> 
# f.gets
# Errno::EISDIR: Is a directory @ io_fillbuf - fd:11 /tmp
# К искючительной ситуации приводит и операции на которые у нас нет прав доступа:
# Errno::EACCES: Permission denied @ rb_sysopen - /var/root

# Узнать размер файла можно при помощи метода size. 
# File.size('tickets.txt') => 83 # размер указан в байтах.

# Помимо класса File существует большое количество вспомогательных классов.Например класс FileTest который помогает нам получить информацию о мета данных.
# Мы можем проверить являеться ли переданный путь дерикторией?
# FileTest.directory? '/home' => true # Если путь являеться директорией, возвращаеться true
# FileTest.directory? '/tickets.txt' => false # Если не являеться возвращаеться false

# При помощи метода file? можем проверить является ли переданный путь обычным файлом?
# FileTest.file? 'tickets.txt' => true 
# FileTest.file? '/home' => false
# Как и в случае любого логического метода возвращаеться либо true либо false.

# Можно проверить путь даже на символическую ссылку.
# FileTest.symlink? 'tickets.txt' => false 

# При помощи метода readable? мы можем узнать можем ли мы читать файл или директорию?
# FileTest.readable? 'tickets.txt' => true 

# Аналогичный метод writable? позволяет выяснить имеем ли мы право создавать в директории файлы, а в случае файлами писать в него.
#  FileTest.writable? 'tickets.txt' => true 

# Метод executable? помогает узнать можем ли мы запускать файл как обычную программу?
# FileTest.executable? 'tickets.txt' => false 
# Если мы задаем директорию, метод собщает нам можем ли мы считывать содержимое данной директории.Есть ли у нас на это права доступа?
# FileTest.executable? '/home' => true 

# класс FileTest поддерживает метод zero? который возвращает true если файл не содержит ни одного байта и false если в файле есть какой-то объем данных.
# FileTest.zero? 'tickets.txt' => false 

# Для работы с дерикториями существует специальныц класс Dir конструктору(new) мы можем передать путь, например точка во всех операционных системах обозначает текущую директорию.
# d = Dir.new('.') => #<Dir:.> 
# Чтобы посмотреть содержимое директории можно воспользоваться методом entries
# d.entries => [".", "..", ".DS_Store", "data_out", "lesson7.1.rb", "lesson7.2.rb", "lesson7.3.rb", "lesson7.4.rb", "lesson7.5.rb", "tickets.txt"] 
# Мы можем видеть список всех файлов и директорий.Обратим внимание на начало списка!Точка ("."} означает текущую директорию, а две точки ("..") означают родительскую.
# Давайте посмотрим содержимое родительской директории. Для этого мы можем воспользоваться снова методом entries при чем мы можем его использовать не только в отнашении объекта но и в отнашении класса Dir.
# Если мы используем для просмотра родительской директории класс Dir то нам нужно обязательно передать ему в качестве параметра путь к директории ('..').
# Dir.entries('..') => [".", "..", ".DS_Store", ".git", "lesson1", "lesson2", "lesson3", "lesson4", "lesson5", "lesson6", "lesson7", "Readme.md"] 
# И так мы поднялись на уровень выше и прочитали содержание родительской дирректории относительно текущей.

# Директории тоже являються коллекциями.Например мы можем подсчитать количество байт которые занимают все файлы в текущей директории.
# Dir.entries('.').reduce(0) { |total, entry| total + File.size(entry) } => 91773 

# Unix утилиты поддерживают простейшие шаблоны.
# Например команда ls возвращает содержимое текущей директории.
# ls
# data_out	lesson7.2.rb	lesson7.4.rb	tickets.txt
# lesson7.1.rb	lesson7.3.rb	lesson7.5.rb

# Mожно указывать простейшие шаблоны.Это не регулярные выражения, но действуют они похожи образом.
# Они позволяют отфильтровать содержимое которое возвращает утилита по определенным правилам.
# Например звездочка (*) обозначает любое количество символов и мы можем с помощью небольшого шаблона с помощью звездочки отфильтровать все руби файлы(.rb) .
# ls *.rb
# lesson7.1.rb	lesson7.2.rb	lesson7.3.rb	lesson7.4.rb	lesson7.5.rb

# Знак вопроса (?) означает один любой символ.
# ls *_?ut #  С помощью такого шаблона мы можем отфильтровать последние два символа в расширение которых заканчиваеться на буквы ut.
# data_out

# ls не единственная утилита которая поддерживает такие шаблоны.Например мы можем удалить файлы при помощи утелиты rm
# rm *_?ut
# Проверим что файл действительно удалился:
# ls -la
# total 208
# drwxr-xr-x   9 test123  staff    306 11 май 14:11 .
# drwxr-xr-x  12 test123  staff    408  1 май 21:42 ..
# -rw-r--r--@  1 test123  staff   6148  4 май 01:03 .DS_Store
# -rw-r--r--@  1 test123  staff  20026 29 апр 16:48 lesson7.1.rb
# -rw-r--r--@  1 test123  staff   9815  2 май 10:52 lesson7.2.rb
# -rw-r--r--@  1 test123  staff  26278  6 май 05:32 lesson7.3.rb
# -rw-r--r--@  1 test123  staff  14794 10 май 15:54 lesson7.4.rb
# -rw-r--r--@  1 test123  staff  15400 11 май 13:45 lesson7.5.rb
# -rw-r--r--@  1 test123  staff     83 10 май 16:03 tickets.txt

# Точно такие же шаблоны можно использовать для фильтрации содержимого директории в руби.
# Для этого мы можем передать шаблон в квадратных скобках[] классу Dir.
# Dir['*'] => ["lesson7.1.rb", "lesson7.2.rb", "lesson7.3.rb", "lesson7.4.rb", "lesson7.5.rb", "tickets.txt"] 
# Давайте отфильтруем руби файлы(.rb) :
# Dir['*.rb'] => ["lesson7.1.rb", "lesson7.2.rb", "lesson7.3.rb", "lesson7.4.rb", "lesson7.5.rb"] 

# Вместо квадратных скобок мы можем использовать специальный метод glob.
# Dir.glob('*.rb') => ["lesson7.1.rb", "lesson7.2.rb", "lesson7.3.rb", "lesson7.4.rb", "lesson7.5.rb"] 
# Давайте отфильтруем только текстовые файлы(.txt):
# Dir.glob('*.txt'  => ["tickets.txt"] 
#
#
#
#
#
#
#
#
#
#
#
#
# 
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

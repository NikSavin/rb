# В текущем уроке разберем гем rake

# 1) Rake - автоматизация сборки
# 2) Конфигурационный файл Rakefile
# 3) Зависимость rake - задач друг от друга
# 4) Параметры rake - задач
# 5) Пространство имен
# 6) Гем ruby - progress

# Многие задачи выполняются как зависимые друг от друга последовательности действий, и для этого идеально подходит гем Rake.
# Давайте при помощи него решим задачу по загрузке технической документации по классам языка Руби с сайта rubydoc.org .
# Мы будем передавать райк задаче список классов которые мы хотим загрузить, а рейк задача будет загружать их с сайта и сохранять в файле на жестком диске.
# Установить гем рейк можно при помощи команды gem install rake, однако для устновки мы воспользуемся гемом bundler с которым мы познакомились в предыдущих уроках.
# Для этого перейдем в Gemfile и добавим строчку gem 'rake' .
# Что бы загрузить все необходимые файлы выполним команду bundle
# bundle
# Fetching gem metadata from https://rubygems.org/.
# Resolving dependencies...
# Fetching rake 13.0.6
# Installing rake 13.0.6
# Using bundler 2.3.13
# Bundle complete! 1 Gemfile dependency, 2 gems now installed.
# Bundled gems are installed into `./vendor/.bundle`

# Для того что бы воспользоваться гемом Рейк. Нам необходимо сначала создать конфигурационный файл Rakefile.
# Мы создаем файл с названием Rakefile и сохраняем его.
# Теперь мы готовы создать первую рейк задачку.
# Создаеться она при помощи метода task. Первому параметру мы передаем символ, название нашей задачи, для примера назовем ее load.
# Метод task принемает блок (do) внутри которого мы можем реализовать любой руби код.Он будет выполняться при вызове задачи.
# Для примера вывидем строку в стандартный поток вывода:
# task :load do
# 	puts 'TODO: load page'
# end
# И так наша задача готова.Давайте её запустим.Для этого в консоли мы набираем утилиту rake и название задачи load.
# MacBook-Pro-test123:lesson8.2 test123$ rake load
# TODO: load page. // Получили результат выполнения гема rake

# Если поптробовать вызвать утелиту рейк без каких либо параметров, то произойдет ошибка:
# MacBook-Pro-test123:lesson8.2 test123$ rake
# rake aborted!
# Don't know how to build task 'default' (see --tasks)
# /Users/test123/Git_add/lesson8.2/vendor/.bundle/ruby/2.4.0/gems/rake-12.3.1/exe/rake:27:in `<top (required)>'
# /Users/test123/.rvm/gems/ruby-2.4.2/bin/ruby_executable_hooks:22:in `eval'
# /Users/test123/.rvm/gems/ruby-2.4.2/bin/ruby_executable_hooks:22:in `<main>'
# (See full trace by running task with --trace) 
# Дело в том что утилита рейк ищет по умолчанию задачу defaulte которая запускаеться в том случае если рейк не передавались никакие параметры.
# Что бы такая ошибка не возникала давайте добавим такую задачу.
# Методу task не обязательно передавать тело блока.Можно просто завести задачу!
# task :default
# Однако сейчас эта задача ничего не будет выполнять.Что бы испраить это мы можем воспользоваться механизмом зависимости задач.
# Например мы можем сообщить рейк что задача default зависит от load.
# В этом случае каждый раз когда мы будем вызывать задачу по умолчанию перед default будет загружаться задача load.
# task :default :load
# Давайте проверим это в консоли.
# MacBook-Pro-test123:lesson8.2 test123$ rake
# TODO: load page.

# Рейк представляет из себя тоже DSL язык.Руби код внутри Rakefile выглядит как специалезированный декларативный язык, при помощи которо мы программируем связанные между собой задачи.
# Впечатление еще больше усиливаеться по тому что мы можем добавлять описание к задаче.
# Для этого используеться метод desc.
# Описание которое дает метод desc будет относиться к первой же задаче которая следует после него.
# Добавим описание с помощью desc в наш Rakefile:
# desc 'Загружаеn страницу класса с ruby-doc.org'
# Давайте попробуем увидеть это описание в консоли: 
# MacBook-Pro-test123:lesson8.2 test123$ rake -T
# rake load  # Загружаеn страницу класса с ruby-doc.org 
# Eсли мы описываем задачу при помощи метода desc они появляются в списке при вызове rake -T в консоли
# Те задачи которые остались без описания здесь не появляются.
# Параметр -T является сокращением от полного варианта --task.Можно использовать и тот и другой варианты.

# Задачи можно переоткрывать.Можно завести несколько задач с одним и тем же именем.
# В отличии от языка руби в рейк будут выполняться все задачи с одинаковыми именами.
# Имя задачи выступает как стадия процесса.Поэтому все задачи которые помечены на выполнение в этой стадии будут выполнены.
# Давайте посмотрим как это работает на примере.
# Мы заводим две задачи которые называються load и изменяем их таким образом что бы мы могли отлечить одну задачу от другой в стандартном патоке вывода:
# desc 'Загружает страницу класса с ruby-doc.org'
# task :load do
#	puts 'TODO: load page (1) .'
# end
#
# task :load do
#	puts 'TODO: load page (2) .'
# end
# Запустим рейк задачу на выполнение и видим что отрабатывает и первая и вторая задача!
# MacBook-Pro-test123:lesson8.2 test123$ rake load
# TODO: load page (1) .
# TODO: load page (2) .
# Получаеться что название задачи это стадии, сколько бы небыло задачь на этой стадии они будут выполнены.

# Впрочем для достижения нашей цели нам достаточно лишь одной задачи.
# Что бы загрузить описание руби класса мы можем с сайта ruby-doc.org .
# Что бы перейти к классу в строке поиска мы должны ввести название класса который мы ищем.
# Давайте найдем класс строки(String) и перейдем на страницу.(https://ruby-doc.com/core-2.4.2/String.html)
# Страница называеться точно так же как класс.Поэтому мы можем скопировать адресную строку и использовать ее в качестве шаблона для страницы класса.
# Для того что бы открыть любую html страницу нам потребуеться библиотека open-uri.Подключим библиотеку в Rakefile.
# require 'open-uri'
# Теперь метод open имеет возможность открытия html страницы.
# rubypage = open('https://ruby-doc.com/core-2.4.2/String.html')
# Давайте вывидем содержимое страницы в консоль.Запускаем утелиту rake.
# rake load
# Получаем содержимое страницы.

# Следующая наша цель, научить rake задачи загружать разные классы и сохранять их в одноименные файлы.
# Давайте на время закоментируем наши две строки: 
# rubypage = open('https://ruby-doc.com/core-2.4.2/String.html')
# puts rubypage.read
# Передать данные внутрь строки можно вторым необязательным параметром метода task [:klasses]
# В этом случае блоку тоже потребуется передать дополнительные параметры |t, arg|.
# Давайте посмотрим на их содержимое.
# task :load, [:klasses] do |t, arg|
# 	p t
# 	p arg
# end
# В консоле помотрим как изменилось описание нашей рейк задачи rake -T:
# MacBook-Pro-test123:lesson8.2 test123$ rake -T
# rake load[klasses]  # Загружает страницу класса с ruby-doc.org
# Видим что после имени рейк задачи(load) появились квадратные скобки в которых указываеться параметр klasses.
# Именно в такой форме мы и можем вызывать нашу задачу!
# Выполняем в консоли команду rake load[String] и получаем результат:
# rake load[String]
# <Rake::Task load => []> // Первый параметр |t| содержит объект с пустым списком.Это зависимость задачи, у нас их не будет поэтому на параметр |t| не обращаем внимания.
# <Rake::TaskArguments klasses: String> // Во втором параметре |arg| появился аргумент String.
# ТАким обазом мы можем передать только один аргумент.Если мы захотим передать второй он здесь не отобразиться!
# rake load[String,Integers]
# <Rake::Task load => []>
# <Rake::TaskArguments klasses: String>
# Как видим ничего не изменилось.

# В первую очередь давайте добавим символ подчеркивания(_) перед параметром |t| в Rakefile:
# task :load, [:klasses] do |_t, arg| // Символом подчеркивания мы сигнализируем другим разработчикам что данный параметр не используеться.Здесь он указан только по тому что блок требует два параметра.
# Первый параметр мы можем получить из объекта arg при помощи квадратных скобок:
# desc 'Загружает страницу класса с ruby-doc.org'
# task :load, [:klasses] do |_t, arg|
#	p arg[:klasses]
# end
# Дополнительные параметры мы можем извлечь при помощи метода extras:
# desc 'Загружает страницу класса с ruby-doc.org'
# task :load, [:klasses] do |_t, arg|
#	p arg[:klasses]
#	p arg.extras
# end
# Давайте убедимся что мы можем добраться до всех параметров!
# MacBook-Pro-test123:lesson8.2 test123$ rake load[String,Integers]
# "String" // Получили первый параметр
# ["Integers"] // Второй параметр
# Если мы укажем второй параметр пустой то мы получим пустой массив!
# rake load[String]
# "String"
# []

# Давайте перепишем нашу rake задачу таким образом что бы она загружала весь список параметров и предоставляла их в виде массива.
# task :load, [:klasses] do |_t, arg|
#	name =  arg[:klasses]
#	ext = arg.extras
#	ext << name // Добавим первый параметр в список дополнительных и тем самым получим полный список параметров.
# 	p ext // Выводим полный список параметров.
# end
# Отправляемся проверять в консоль.
# При запуске с двумя параметрами теперь мы получаем массив из двух строк:
# MacBook-Pro-test123:lesson8.2 test123$ rake load[String,Integer]
# ["Integer", "String"]
# Запускаем задачу с одним параметром и получаем массив из одной строки:
# MacBook-Pro-test123:lesson8.2 test123$ rake load[Integer]
# ["Integer"]
# Запускаем задачу без параметров и получаем массив с элементом nil:
# MacBook-Pro-test123:lesson8.2 test123$ rake load
# [nil]
# Избавимся от nil при помощи метода compact. Для этого переходим в Rakefile и добавляем метод compact в вывод массива (p ext.compact)
# MacBook-Pro-test123:lesson8.2 test123$ rake load
# []

# Rake задачи можно группировать в пространство имен которые выводяться при помощи метода namespace.
# Первым параметром мы указываем символ(:docs) который служит названием пространства имен.
# В блоке метода(do) мы размещаем рейк задачи 
# namespace :docs do
#	desc 'Загружает страницу класса с ruby-doc.org'
#	task :load, [:klasses] do |_t, arg|
#		name =  arg[:klasses]
#		ext = arg.extras
#		ext << name
#		p ext.compact
#	end
# end
# Давайте посмотрим как изменился отчет команды rake -T:
# MacBook-Pro-test123:lesson8.2 test123$ rake -T
# rake docs:load[klasses]  # Загружает страницу класса с ruby-doc.org
# Обращаем внимание что перед задачей указываеться пространство имен docs.
# Для того что бы вызвать рейк задачу нам потребуеться теперь его указывать.Т.е. задача теперь вызываеться следующим образом:
# MacBook-Pro-test123:lesson8.2 test123$ rake docs:load[String]
# ["String"]
# Так можно изолировать одноименные задачи по направлениям.
# Например часть задач обслуживает документацию, часть обслуживает базу данных, другая занимаеться генерацией кода.
# Схожие по назначению задачи можно объеденять в пространство имен.

# Давайте допишем нашу программу таким образом что бы она загружала в файл документацию с ruby-doc.org и сохраняла её текстовый файл.
# Т.К. у нас есть массив классов(ext.compact) мы можем обойти его при помощи итератора each и загрузить каждый класс отдельно.
# namespace :docs do
#	desc 'Загружает страницу класса с ruby-doc.org'
#	task :load, [:klasses] do |_t, arg|
#		name =  arg[:klasses]
#		ext = arg.extras
#		ext << name
#		ext.compact.each do |klass| // проходим массив при помощи итератора each и загружаем его отдельно.
#			url = format('https://ruby-doc.com/core-2.4.2/%s.html', klass) // Формируем адресс для каждого из классов и загружаем его отдельно.
#			File.write( "#{klass}.txt", open(url).read ) // Полученый класс мы окрываем при помощи метода open читаем его при помощи метода read и сохраняем в одноименный файл.
#		end
#	end
# end 
# Давайте запустим рейк задачу на выполнение и посмотрим на содержимое нашей директории.
# MacBook-Pro-test123:lesson8.2 test123$ rake docs:load[String,Integer]
# MacBook-Pro-test123:lesson8.2 test123$ ls -la
# total 968
# drwxr-xr-x  11 test123  staff     374 20 май 18:23 .
# drwxr-xr-x  14 test123  staff     476 20 май 03:08 ..
# -rw-r--r--@  1 test123  staff    6148 20 май 18:23 .DS_Store
# drwxr-xr-x   3 test123  staff     102 20 май 14:29 .bundle
# -rw-r--r--   1 test123  staff      96 20 май 15:21 Gemfile
# -rw-r--r--   1 test123  staff     149 20 май 14:38 Gemfile.lock
# -rw-r--r--   1 test123  staff  122014 20 май 18:23 Integer.txt
# -rw-r--r--@  1 test123  staff     434 20 май 18:21 Rakefile
# -rw-r--r--   1 test123  staff  331400 20 май 18:23 String.txt
# -rw-r--r--@  1 test123  staff   18022 20 май 18:24 lesson8.3.rb
# drwxr-xr-x   3 test123  staff     102 20 май 14:32 vendor
# Видим что у нас появилось два файла: String.txt и Integer.txt

# Если мы перечислим большое количество классов и скорость загрузки у нас будет не велика, то мы давольно долго можем ожидать результата.
# Для того что бы визуалезировать процесс мы можем воспользоваться гемом ruby-progressbar.
# Подключаем его в Gemfile:
# gem 'ruby-progressbar', '~>1.9.0'

# Для того что бы воспользоваться возможностями гема ruby-progressbar давайте подключим его в Rakefile при помощи ранее изученной инструкции Bundler.require(:default)
# require 'rubygems'
# require 'bundler/setup'
# Bundler.require(:default) 
# Теперь мы готовы воспользоваться гемом.
# В Rakefile мы задействуем класс ProgressBar и его метод create(progressbar = ProgressBar.create).
# Можно не передавать никаких параметров но мы воспользуемся параметр total(total: ext.size) для того что бы задать размер progressbar.
# В качесте размера мы зададим количество переданных в задачу классов(ext.size).Если мы укажем объемный список классов(size) то прогресс будет отмечатся с каждым загруженным классом.
# После этого нам достаточно воспользоваться методом increment.
# namespace :docs do
#	desc 'Загружает страницу класса с ruby-doc.org'
#	task :load, [:klasses] do |_t, arg|
#		name =  arg[:klasses]
#		ext = arg.extras
#		ext << name
#		progressbar = ProgressBar.create(total: ext.size)
#		ext.compact.each do |klass|
#			url = format('https://ruby-doc.com/core-2.4.2/%s.html', klass)
#			File.write( "#{klass}.txt", open(url).read )
#			progressbar.increment
#		end
#	end
# end
# Запустим задачу на выполнение. Укажем побольше классов что бы было интересней наблюдать за прогресс-барром:
# MacBook-Pro-test123:lesson8.2 test123$ rake docs:load[BasicObject,Object,String,Integer,Float]
# Progress: |====================================================================|



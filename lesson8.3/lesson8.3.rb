# Сегодня мы рассмотрим тесты.
# 1) Типы тестов
# 2) Фреймворки тестирования
# 3) MiniTest

# Тесты можно условно разделить: 
# 1 - Unit тесты => Предназначены для тестирования отдельной функционлальности, например какаго-то метода или утверждения.
# 2 - Конфигурационные => Проверяют функциональность(фичу).Например: Зашли на страницу => Нажели кнопку => Получили результат.
# 3 - Приемочные => Восновном нуны для проджект менеджера аналитика и тимлидов. Они пишутся заранее и фиксируют какой нибудь функционал который должен быть обязательно в конечнй программе.
# 4 - Ручное тестирование => Некоторые задачи очень сложно тестировать автоматически, например верстку сайта, расположение кнопок. Такую работу обычно выполняют вручную, Кроме того, автоматические тесты редко покрывают все возможные случаи. Поэтому ручное тестирование должно вскрывать постоянно возникающие ошибки и оформлять их в виде тест-кейсов которые потом подлежат автоматизации.

# Распределение по количеству тестов будет выглядеть примерно следующим образом:
# Unit тестов должно быть максимально много, они быстро выполняються и позвояют вскрывать низкоуровневые ошибки 
# Интеграционных тестов должно быть меньше чем unit тестов.Они выполняються гораздо дольше по времени и должны покрывать только важный функционал.Здесь уже не нужно писать тесты ради тестов.
# Приемочных тестов должно быть еще меньше и часто эта работа выполняеться вручную.Очень трудно запрограммировать что-то не имея на руках протатип или программу, а приемочные тесты это как раз тот случай когда мы пишем тесты до того как начали работать над самой программой.
# Ручного тестирования должно быть еще меньше.Человек не может заменить машину. Если тестировщик вынужден тестировать программу после каждого коммита, он может не справиться или начнет ошибаться. В идеальных условиях задача тестировщика руководить всем процессом тестирования: Писать тест-кейсы, находить часто возникающие ошибочные ситуации, тестировать те случаи которые трудно поддаються автоматизации.

# Пока мы не используем тесты их преимущества кажутся не очевидными, однако они дают контроль над правильностью выполнения программы.
# Если у нас программа покрыта тестами, то при внисении изменений в код, тесты будут сигналезировать нам о том что изменения ломают какую-то часть функционала.
# Тесты не будут давать сломать то что уже работает правильно.
# Тесты это дополнительный код ревью.Причем этот код ревью не возможно провести формально.
# При помощи тестов доказываеться что код работает правильно,  кроме того тесты отлично вскрывают плохо написанный код или плохо спроектируюмую программу.Если тесты писать сложно, с кодом явно что то не так, это явный сигнал для рефакторинга.

# Разумеется у тестов есть и обратная сторона медали.
# Тесты снижают, но не гарантируют отсутствие ошибок.Высокое покрытие тестами может создать иллюзию того что программа работает правильно.
# Однако полное доказательство при помощи теста того что программа работает правильно, потребует усилий и тестов на порядок больше чем сама программа.
# Тесты это тоже код, они требуют времени на создание и сопровождение.Тесты не так легко писать, прийдеться потратить время, а значит и усилия для того что бы научиться их писать.

# Руби сообщество фанатически относится к тестированию.Более того руби фреймворки часто используются для тестирования программ написанных на других языках.
# Наиболее популярными фреймворками являються: MiniTest, RSpec, Cucumber
# MiniTest - тесты на нем органезованны с помощью классов и методов которые начинаються с префиксa test.
# Minitest входит в стандартную библиотеку руби, поэтому популярен.
# Rspec - альтернативный фреймворк который реалезует DSL язык проектирования(предметно ориентированный язык полностью посвещенный тестированию)
# Cucumber - фреймворк который создан для создания приемочных тестов.Для создания спецификаций на естественном языке, например на русском.Предполагается что такой фреймворк используеться совместно разработчиками и менеджерами или аналитиками для создания приемочных тестов.
# Как разработчики мы чаще всего будем встречаться с minitest и rspec.Это рабочие лошадки в сообществе руби.

# Начнем рассмотрение фреймворков с MiniTest.
# Для того что бы воспользоваться минитестом установим его через bundler. 
# В гемфайле мы подключим гем минитест и установим его при помощи команды bundle.
# Теперь давайте разработаем небольшой класс Hello
require 'minitest/autorun'

#class Hello
#	def say(str) # В классе будет единственный метод say который возвращает параметр(str) и возвращает фразу например - Hello world если параметр str будет принемать значение Hello world

#	end
#end
# Для того что бы воспользоваться минитестами их нужно для начала подключить.Сделаем это воспользовавшись методом require
# Для начала тестирования следует создать класс который начинается с префикса Test.
# Класс(TestHello) следует унаследовать от TestCase класса MiniTest
# class TestHello < MiniTest::Unit::TestCase
# В классе мы можем предопределить метод setup который выполняеться до начала всех тестов.
#	def setup
# В методе определим инстанс переменную object которая инециалезируеться объектом класса Hello.  
#		@object = Hello.new
#	end
# Теперь мы готовы писать тесты.
# Тесты это методы которые начинаються с префикса test.Как и все методы они пишутся в снейк режиме.
#	def test_that_hello_return_a_string # Название теста должно обозначать то что мы тестируем.
# Для тестирования мы используем утверждения, специальные методы которые нам предоставляет minitest
# 		assert_instance_of String, @object.say('test') # Здесь мы проверяем что возвращаемое значение метода say это строка.
# Сейчас у нас метод say возвращает значение nil ( def say(str) ). Поэтому тест должен упасть.
#                                                ( end )
#	end
# end
# Запускаем нашу программу на выполнение и видим что тест упал:
# 1) Failure:
# TestHello#test_that_hello_return_a_string [lesson8.3.rb:60]:
# Expected nil to be an instance of String, not NilClass.
# Ожидаеться значение класса string, а полученo nil значение.

# Мы можем поправить нашу программу что бы тест проходил, но сперва закоментируем тест выше.
class Hello1
	def say1(string)
		"Hello #{string}!"
	end
end

class TestHello1 < MiniTest::Unit::TestCase
	
	def setup
		@obj = Hello1.new
	end

	def test_that_hello1_return_string1
		assert_instance_of String, @obj.say1('test')
	end

	def test_that_hello1_corrent_phrase 
		assert_equal 'Hello world!', @obj.say1('world') 
	end

end
# Запускаем программу и видим что тесты прошли:
# MiniTest::Unit::TestCase is now Minitest::Test. From lesson8.3.rb:78:in `<main>'
# Run options: --seed 1322
# Running:
# .
# Finished in 0.000978s, 1022.4949 runs/s, 1022.4949 assertions/s.
# 1 runs, 1 assertions, 0 failures, 0 errors, 0 skips
# Вместо сообщения об ошибке у нас одна точка. Это значит что наш тест прошел успешно!

# Если мы обратимся к документации minitest то мы можем обнаружить большое количество самых разнообразных утверждений.
# Давайте ознакомимся с assert_equal это самое простое утверждение которое сравнивает равенство одного аргумента с другим.
# Напишем еще один тест с использованием этого утверждения.
# Сейчас у нас в классе TestHello1 только один тест который прверяет что метод say возвращает строку.
# Давайте проверим что эта строка начинаеться именно с Hello.
# Добавим в наш класс TestHello1 тест - tets_that_hello1_corrent_phrase
# В тесте мы хотим убедиться что вызов @obj.say1 с передачей ему аргумента в качестве строки world вернет Hello world!.

# Далее мы продолжаем использование инструментов тестирования в руби. 
# Сегодня рассмотрим rspec и cucumber.

# Начнем с rspec.
# Для начала запишем его в Gemfile.Далее запустим команду bundle в терминале что бы его установить.
# Тестировать мы будем class Hello. Для тестов создадим отдельную папку spec.В ней мы будем располагать файлы с тестами.
# При создании файла важно чтобы у него был суфикс spec именно на них будет реагировать утилита rspec которая запускает тесты.
# Создаем наш первый файл и даем ему имя example_spec.rb.
# Напишем первый тест.Для этого мы обращаемся к классу Rspec и его методу describe.
# discribe принемает блок внутри которого мы можем размещать тесты(см. папку spec).
# тесты задаются методом it.
# Внутри тестов мы можем писать утверждения.(expect(false).to by_falsy)
# Обратим внимание что тесты задаються как декларативный язык.Человек не знакомый с руби может читать такие тесты как обычные выражения.
# Пример будет работать если ожидаеться что объект false будет возвращать false.Пример несколько надуман, но зато демонстрирует работу тестов и так как выглядит Rspec.

# Запустим тест на выполнение, для этого мы используем утилиту rspec которая была установлена вместе с гемом и указываем папку у нас она называется spec.
# RSpec.describe 'Привет' do # В методе discribe мы описываем что мы тестируем
#	it 'Должен работать когда' do # В методе it реализуем тест
#	  expect(false).to be_falsy
#	end
# end

# Каждый вызов метода it является отдельным тестом.
# Давайте напишем еще один тест в example_spec.rb
# RSpec.describe 'Привет' do # В методе discribe мы описываем что мы тестируем
#	it 'Должен работать когда' do # В методе it реализуем тест
#	  expect(false).to be_falsy
#	end
#
#	it 'Должен работать когда' do
#	  ecpect(true).to be_truthy
#	end
# end 
# Запускаем тесты и видим что у нас два пройденных теста.
# MacBook-Pro-test123:lesson8.3 test123$ rspec spec
# ..
# Finished in 0.00361 seconds (files took 0.10474 seconds to load)
# 2 examples, 0 failures

# Команда rspec может принимать параметры.НАпример мы можем передать команде формат(--format d)
# MacBook-Pro-test123:lesson8.3 test123$ rspec spec --format d
# Привет
#  Должен работать когда
#  Должен работать когда
# Finished in 0.00233 seconds (files took 0.11261 seconds to load)
# 2 examples, 0 failures
# В этом случае мы получаем описание которое мы задали в методе describe и it.В идеале они должны складываться в законченые предложения.
# Исправим наши описания тестов:
# RSpec.describe 'Привет' do # В методе discribe мы описываем что мы тестируем
#	it 'должен работать в случае false' do # В методе it реализуем тест
#	  expect(false).to be_falsy
#	end
#
#	it 'должен работатьв случае true' do
#	  expect(true).to be_truthy
#	end
# end
# Убедимся что теперь описание стало более понятно:
#MacBook-Pro-test123:lesson8.3 test123$ rspec spec --format d
# Привет
#  должен работать в случае false
#  должен работатьв случае true
# Finished in 0.00311 seconds (files took 0.18245 seconds to load)
# 2 examples, 0 failures

# Rspec это не просто тесты, они позволяют создать спецификацию программы

# Если посетить страницу https://github.com/rspec/rspec-expectations то мы можем убедиться что утверждений очень и очень много, практически на все случаи жизни. 

# Давайте создадим еще один файл between_spec.rb в папке spec. ОБЯЗАТЕЛЬНО нужно указыватьс spec в названии файла, в противном случаи rspec его просто не будет видеть.
# Попробуем воспользоваться утверждением bebetween которое проверяет вхождение числа в какой либо диапазон.
# RSpec.describe 'Число' do
#	it 'должно входить в диапазон' do
#	  expect(5).to be_between(1, 10)
#	end
# end
# Запускаем программу на выполнение(rspec spec) и видим что наши три теста проходят корректно:
# MacBook-Pro-test123:lesson8.3 test123$ rspec spec
# ...
# Finished in 0.00972 seconds (files took 0.17382 seconds to load)
# 3 examples, 0 failures

# Можно запускать не все тесты разом, а конкретные файлы.
# Для этого мы указываем путь к файлу(rspec spec/путь к файлу с тестами).
# MacBook-Pro-test123:lesson8.3 test123$ rspec spec/example_spec.rb # Сначала указываем утилиту rspec потом папку spec и потом указываем файл example_spec.rb
# ..
# Finished in 0.00783 seconds (files took 0.1772 seconds to load)
# 2 examples, 0 failures

# Мы можем так же запустить и отдельный тест в нашем файле, игнорируя другие тесты.
# Давайте запустим тест в файле example_spec.rb который находиться на второй строке, при этом игнорируя тест который находиться на пятой.
# Для этого мы указываем путь (rspec spec/example.rb) затем указываем двоеточие(:) и после этого указываем номер строки на которой находиться тест который мы хотим запустить.В нашем случае это будет пятая строка(5).
# MacBook-Pro-test123:lesson8.3 test123$ rspec spec/example_spec.rb:5
# Run options: include {:locations=>{"./spec/example_spec.rb"=>[5]}}
# .
# Finished in 0.00285 seconds (files took 0.18096 seconds to load)
# 1 example, 0 failures

# Так же можно реализовать отложенный тест это делаеться при помощи метода xit.
# Давайте посмотрим пример в файле between_spec.rb
# xit 'входит в диапазон массивов' do
#	expect([1, 2, 3]).to include(1)
# end
# Запускаем тесты и вместо зеленой точки получаем желтую звездочку(*):
# MacBook-Pro-test123:lesson8.3 test123$ rspec spec/between_spec.rb 
# .*
# Pending: (Failures listed here are expected and do not affect your suite's status)
# 1) Число входит в диапазон массивов
     # Temporarily skipped with xit
     # ./spec/between_spec.rb:6
# Finished in 0.00678 seconds (files took 0.18525 seconds to load)
# 2 examples, 0 failures, 1 pending
# Вернем тесту метод it что бы наши тесты проходили корректно.

# Точно так же как и в случае с MiniTest у нас есть возможность выполнять код до начала всех тестов и после, используя be for и auto calback
# Кроме того rspec помогает исполнить большое количество вспомогательных методов и синонемов.
# Давайте создадим файл callbacks_spec.rb в котором продемонстрируем дополнительные возможности работы с rspec.
# У метода describe есть синоним context.Более того методы describe и context могут быть вложенны друг в друга.Например мы можем протестировать объект 'Ключь-значение', объект 'строки', объект 'пользователя':
# Внутри каждого из этих контекстов мы можем разместить свои собственные тесты, тем самым группируя их по назначению.
# RSpec.describe 'Объект' do
#	context 'ключ-значение' do
#	end
#
#	context 'строки' do
#	end
#
#	context 'пользователя' do
#	end
# end
# Мы можем использовать специальный метод let который предоставляет нам ленивую загрузку.
# Объект загружаеться только в том случае если к нему есть обращение.Если обращения нет, то загрузка не происходит.
# require 'ostruct' # Подключаем OpenStruct.
#
# RSpec.describe 'Объект' do
#	context 'ключ-значение' do
#		let(:object) do # Мы создаем объект object при помощи OpenStruct
#		  OpenStruct.new(key: 'ключ', value: 'значение') # Создает object с атрибутами key и value
#        end
#
#	   it 'должен содержать корректный ключ' do
#	   	expect(object.key).to eq('ключ') # Когда в этой строке мы обращаемся к объекту object и запрашиваем key мы должны получить значение ключ.
#	   end
#    end
# end
# Если обращения в к объект object нигде в тестах не будет, то OpenStruct вообще не будет создаваться.
# Давайте внутри контекста ключ значение создадим дополнительный контекст которым будет протестированно изменение клча key.
# Для того что бы выполнить задачу перед группой тестов мы можем воспользоваться методом мы можем воспользоваться колбеком beforce.
# Колбек может быть выполнен один раз перед всеми тестами или каждый раз перед каждым тестом.
# Мы хотим добиться второго поведения по этому мы передаем ему в качестве параметра символ each.
# require 'ostruct'
# 
# RSpec.describe 'Объект' do
#   context 'ключ-значение' do
#     let(:object) do
#       OpenStruct.new(key: 'ключ', value: 'значение')
#     end
# 
#     it 'должен содержать корректный ключ' do
#       expect(object.key).to eq('ключ')
#     end
# 
#     context 'с измененным параметром' do
#       before(:each) do 
#         object.key = 'новый ключ' # Внутри колбека изменяем у object значение ключа, используем вместо ключа строку "новый ключ".
#       end
# 
#       it 'должен содержать новый ключ' do # В тесте убеждаемся что сейчас у object атрибут key возвращает строку  "новый ключ"
#         expect(object.key).to eq('новый ключ')
#       end
#     end
#   end
# end
# Давайте запустим тесты на выполнение и убедимся что тесты работают корректно: 
# MacBook-Pro-test123:lesson8.3 test123$ rspec spec
# ......
# Finished in 0.01208 seconds (files took 0.17741 seconds to load)
# 6 examples, 0 failures

# Если MiniTest и Rspec мы используем для описания поведения объекта, то Cucumber мы используем для описания поведения приложения.
# Очень часто Cucumber используеться для создания приемочных тестов.Более того cucmber позволяет писать тестовый сценарий на обычном, в том числе русском языке.
# Давайте установим гем при помощи команды gem install cucumber -v 3.1.0
# Проинициалезируем его в нашей паапке при помощи команды cucumber --init
# Теперь все готово для работы.У нас появилась папка featurse.давайте создадим в ней первый тест hello features.
# Создаем файл  hello.feature.
# Для того что бы создавать файлы на русском языке нам требуеться указать внутри файла директиву language: которую мы указываем после символа # (# language: ru)
# Далее мы описываем то что мы тестируем, для этого мы используем ключивое слово Функционал. После этого нам нужно описать поведение нашего функционала, делаем мы это при помощи ключивого слова Сценарий(Обратим внимание что предложения в сценарии начинаються со слов Допустим, Если, То)
# Функционал: пусть класс приветствует нас
# 	Для того чтобы изучить Rspec и Cucumber 
# 	Хорошо бы увидеть как Cucumber работает на практике 
# 	Напишем простейший Hello World
#
# 	Сценарий: Пусть класс скажет привет
#		  Допустим дан объект класса
#		  Если я вызываю его метод say
# 	  То я получаю строку 'Привет!'
# Давайте запустим тест на выполнение.Для Этого используем команду cucumber передавая ей путь к папке с тестами cucumber features.
# MacBook-Pro-test123:lesson8.3 test123$ cucumber features
# language: ru
# Функционал: пусть класс приветствует нас
# 	Для того чтобы изучить Rspec и Cucumber 
# 	Хорошо бы увидеть как Cucumber работает на практике 
# 	Напишем простейший Hello World
# 
#   Сценарий: Пусть класс скажет привет # features/hello.feature:8
#     Допустим дан объект класса        # features/hello.feature:9
#     Если я вызываю его метод say      # features/hello.feature:10
#     То я получаю строку 'Привет!'     # features/hello.feature:11
# 
# 1 scenario (1 undefined)
# 3 steps (3 undefined)
# 0m0.053s
# 
# You can implement step definitions for undefined steps with these snippets:
# 
# Допустим('дан объект класса') do
#   pending # Write code here that turns the phrase above into concrete actions
# end
# 
# Если('я вызываю его метод say') do
#   pending # Write code here that turns the phrase above into concrete actions
# end
# 
# То('я получаю строку {string}') do |string|
#   pending # Write code here that turns the phrase above into concrete actions
# end
# Видим что у нас отработал сценарий, более того мы видим что cucumber предлогает нам реализацию этого сценария.
# Создание методов Допустим, Если, То.
# Вместо строк которые передаются в качестве параметров этим выражениям можно использовать регулярные выражения.

# Сценарии реализуються в папке step_definitions.Давайте создадим там файл hello_steps.rb
# Создаем в нем класс Hello и в нем единственый метод say который возвращает строку 'Привет!'
# class Hello
# 	def say
# 		'Привет!'
# 	end
# end
# Далее нам необходимо реализовать шаги нашего сценария.
# Создаем метод Допутим передавая ему либо строку 'дан объект класса' либо регулярное выражение которое будет ему соответствовать /^дан объект класса$/
# Внутри метода мы инициалезируем инстанс переменную @hello которой передаем объект класса Hello.
# Допустим /^дан объект класса$/ do
# 	@hello = Hello.new
# end
# Далее нам нужно реализовать метод Если.В методе мы сохраняем результат @hello.say и сохраняем результат в другую инстанс переменную @msg.
# Если('я вызываю его метод say') do
# 	@msg = @hello.say
# end
# Последним шагом мы реалезуем метод То из которого мы извлекаем строку и реализуем метод сравнения.
# То /^ я получаю строку '([^']*)'$/ do |str|
# 	@msg == str
# end
# Давайте посмотрим на полную версию нашей программы в файле hello_steps.rb и попробуем запустить наш тест:
# MacBook-Pro-test123:lesson8.3 test123$ cucumber features
# language: ru
# Функционал: пусть класс приветствует нас
#	Для того чтобы изучить Rspec и Cucumber 
#	Хорошо бы увидеть как Cucumber работает на практике 
#	Напишем простейший Hello World
#
#  Сценарий: Пусть класс скажет привет # features/hello.feature:8
#    Допустим дан объект класса        # features/step_definitions/hello_steps.rb:7
#    Если я вызываю его метод say      # features/step_definitions/hello_steps.rb:11
#    То я получаю строку 'Привет!'     # features/step_definitions/hello_steps.rb:15
#
# 1 scenario (1 passed)
# 3 steps (3 passed)
# 0m0.020s
# Выше видем что тесты проходят корректно.
# Таким образом мы описали функционал нашей программы, Написали сценарий поведения и последовательно реализовали нашу программу.Причем всё это мы сделали на русском языке.
# Таким образом со сценарием уже могут работать не только руби программисты но и тетстировщики, аналитики и проджект менеджеры.
